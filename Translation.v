Require Import RAC.Definitions.
Require Import RAC.Notations.
Require Import RAC.Utils.
Require Import String.
Require Import BinaryString.
Open Scope string_scope.
Open Scope mini_c_scope.
Require Import List.
Import ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Export CounterMonad.
Require Import ZArith.ZArith.

Open Scope mini_gmp_scope.

(* macro definitions *)

(* Definition τ_ASSGN (τ:gmp_t) v (e:c_exp) : statement := match ty e with
    | Mpz => < set_z(v,"e") >
    | C_Int => < set_i(v,"e") >
    | _ => Skip
end. *)


Definition mpz_ASSGN v (e:c_exp) : statement := match ty e with
    | Mpz => < set_z(v,"e") >
    | C_Int => < set_i(v,"e") >
    | _ => Skip
end.

Definition int_ASSGN v (e:c_exp) : statement := match ty e with
    | C_Int =>  <{ v = e }>
    | Mpz => < v = get_int("e") >
    | _ => Skip
end.

Definition Z_ASSGN (τz:gmp_t) v z : statement := match τz with
    | C_Int => <{ v = z }>
    | Mpz => < set_s(v,"s")>
    | _ => Skip
end.

Definition CMP c e₁ e₂ v₁ v₂ : statement := match ty e₁, ty e₂ with
    |  C_Int,C_Int => 
        <{ 
            if (e₁ < e₂) c = 0-1
            else if (e₁ > e₂) c = 1
            else c = 0
        }>
    | _,_ => 
        let a1 := mpz_ASSGN v₁ e₁ in 
        let a2 := mpz_ASSGN v₂ e₂ in
        < a1 ; a2 ; < c = cmp(v₁,v₂)> >
end
.


Definition binop_ASSGN(fsl_op:fsl_binop_int) (v:gmp_t ⨉ 𝓥) e₁ e₂ r v₁ v₂ : statement := 
    let (τ,c) := v in
    match τ,(ty e₁),(ty e₂) with
    | C_Int,C_Int,C_Int =>  let res := BinOpInt e₁ (□ fsl_op) e₂ in <{ c = res }>
    | _,_,_ => 
        let s1 :=  mpz_ASSGN v₁ e₁ in
        let s2 :=  mpz_ASSGN v₂ e₂ in
        let s3 := match τ with
                    | C_Int => <(op fsl_op r v₁ v₂) ; (int_ASSGN c r)>
                    | Mpz => op fsl_op c v₁ v₂
                    | _ => Skip
                    end
        in <s1;s2;s3>

    end
    .


Definition ψ := 𝔏 ⨉ (𝔏 ⇀ 𝐼) ⇀ 𝓥 . (* global definitions env *)

Definition Γᵥ := 𝔏 ⇀ 𝓥 ⨉ 𝐼. (* correspondence binder -> variable and interval infered from it *)

Notation "'Γ' x" := (Γᵥ x,Γᵢ x) (at level 99).

Definition var_list := (gmp_t ⨉ 𝓥) ⃰.


(* helper functions *)
Definition DECLS (vars:var_list)  : statement := (* generates declarations *)
    List.fold_right (fun (v:gmp_t ⨉ 𝓥) a => let (t,s) := v in   (*fixme t -> int*)
    <<[int s]> ; a>) Skip vars.

Definition INITS (vars : var_list) : statement := (* generates initialization *)
    List.fold_right 
    (
        fun (v:gmp_t ⨉ 𝓥) a => let (t,z) := v in 
        match t with
        | Mpz => <init(z) ; a>
        | C_Int | _  => a
        end        
    ) Skip vars.

Definition CLEARS (vars : var_list) : statement := (* generates deallocation *)
List.fold_right 
(
    fun (v:gmp_t ⨉ 𝓥) a => let (t,z) := v in 
    match t with
    | Mpz => <cl(z); a>
    | C_Int | _  => a
    end        
) Skip vars.



Record translation_result T: Type := mkTR
{
    chunk: T ;  (* code chunk  resulting of the translation *)
    env: ψ; (* global definitions i.e. routines generated by the translation *)
    glob:c_decl ⃰ ; (* mini-c globals generated during translation *)
}.


Record translated_statement {T: Type} := mkSTR
{
    tr : translation_result T;
    decls: var_list ; (* fresh variables generated by the translation *)
    res: 𝓥  ; (* variables containing the result *)
}.


Definition fresh_variable :=  c <- fresh ;; ret ("_v" ++ string_of_nat c)%string.

Fixpoint translate_predicate (e: ψ) (p: predicate) : state := match p with
    | P_True => 
        c <- fresh_variable ;;
        let decl := [(Ctype C_Int,c)] in
        let code := <{ c = 1 }> in
        ret (mkSTR statement (mkTR statement code e nil) decl c)
    | P_False => 
        c <- fresh_variable ;; 
        let decl := [(Ctype C_Int,c)] in
        let code := <{ c = 0 }> in
        ret (mkSTR statement (mkTR statement code e nil) decl c)

    | Not t => 
        c <- fresh_variable ;; 
        p_tr <- translate_predicate e t ;;
        let _res := p_tr.(res) in
        let decl := (Ctype C_Int,c)::p_tr.(decls) in
        let code := S_Seq p_tr.(tr).(chunk statement) <{if _res c = 0 else c = 1 }> in
        ret (mkSTR statement (mkTR statement code p_tr.(tr).(env statement) nil) decl c)
    
    | Disj p1 p2 => 
        c <- fresh_variable ;;
        tr_p1 <- translate_predicate e p1;;
        let p1_res := tr_p1.(res) in
        let p1_code := tr_p1.(tr).(chunk statement) in
        tr_p2 <- translate_predicate tr_p1.(tr).(env statement) p2 ;;
        let p2_res := tr_p2.(res) in
        let p2_code := tr_p2.(tr).(chunk statement) in
        let decl := (Ctype C_Int,c)::tr_p1.(decls) ++ tr_p2.(decls) in
        let code := <p1_code; if p1_res c = 1 else <p2_code ; <{c = p2_res}>> > 
        in
        ret (mkSTR statement (mkTR statement code tr_p2.(tr).(env statement) nil) decl c)

    | P_BinOp t1 fsl_op t2 =>
        c <- fresh_variable ;;
        tr_t1 <- translate_term e t1 ;;
        let t1_code := tr_t1.(tr).(chunk statement) in
        tr_t2 <- translate_term tr_t1.(tr).(env statement) t2 ;;
        let t2_code := tr_t2.(tr).(chunk statement) in
        let decl := (Mpz, "v1")::(Mpz,"v2")::(Ctype C_Int,c)::tr_t1.(decls) ++ tr_t2.(decls) in
        let comp := CMP c tr_t1.(res) tr_t2.(res) "v1" "v2" in 
        let code := <t1_code ; t2_code; comp ; (Assign c (BinOpBool c (◖fsl_op) 0))>  in
        ret (mkSTR statement (mkTR statement code tr_t2.(tr).(env statement) nil) decl c)

    | Call _ _ =>  let _ := translate_term in ret (mkSTR statement (mkTR statement Skip e nil) nil "") (* fixme : defined ? *)
end 

with translate_term (e: ψ) (t : fsl_term) : state := match t with
    | T_Z z =>
        c <- fresh_variable ;;
        let decl := [(Ctype C_Int, c)] (*fixme *) in 
        let code := Z_ASSGN C_Int c z in
        ret (mkSTR statement (mkTR statement code e nil) decl c)

    | T_Id v => ret (mkSTR statement (mkTR statement Skip e nil) nil "")

    | T_BinOp t1 _op t2 => 
        let τ := Ctype C_Int in (*fixme*)
        c <- fresh_variable ;;
        v1 <- fresh_variable ;;
        v2 <- fresh_variable ;;
        r <- fresh_variable ;;
        t1_tr <- translate_term e t1 ;; 
        let t1_code := t1_tr.(tr).(chunk statement) in
        let t1_res := t1_tr.(res) in
        t2_tr <- translate_term t1_tr.(tr).(env statement) t2 ;; 
        let t2_code := t2_tr.(tr).(chunk statement) in
        let t2_res := t2_tr.(res) in
        let decl := (τ,c) :: (Mpz,v1) :: (Mpz,v2) :: (Mpz,r) :: t1_tr.(decls) ++ t2_tr.(decls) in
        let assgn := binop_ASSGN _op (τ,c) t1_res t2_res r v1 v2 in
        let code := < t1_code ; t2_code ; assgn > in
        ret (mkSTR statement (mkTR statement code t2_tr.(tr).(env statement) nil) decl c)

    | Conditional p t1 t2 => 
        c <- fresh_variable ;;
        let τ := Ctype C_Int in (*fixme*)
        p_tr <- translate_predicate e p ;;
        t1_tr <- translate_term p_tr.(tr).(env statement) t1 ;; 
        let t1_code := t1_tr.(tr).(chunk statement) in
        let t1_res := t1_tr.(res) in
        t2_tr <- translate_term t1_tr.(tr).(env statement) t2 ;; 
        let t2_code := t2_tr.(tr).(chunk statement) in
        let t2_res := t2_tr.(res) in
        let p_code  := p_tr.(tr).(chunk statement) in 
        let p_res := p_tr.(res) in
        let t1_assgn :=  int_ASSGN c t1_res (* fixme macros *) in
        let t2_assgn :=  int_ASSGN c t2_res (* fixme macros *) in
        let decl := (τ,c) :: p_tr.(decls) ++ t1_tr.(decls) ++ t2_tr.(decls) in
        let code := 
            <
                p_code;
                if (p_res) <{ 
                   t1_code ;
                   t1_assgn
                }> 
                else <{ 
                    t2_code ;
                    t2_assgn
                }>
            > in
        ret (mkSTR statement (mkTR statement code t2_tr.(tr).(env statement) nil) decl c)
    end
.
 


(* translation of statements *)
Fixpoint translate_c_statement (env: ψ) (s : statement) : state := match s with
    | LAssert p  => 
        p_tr <- translate_predicate env p ;;
        let d := DECLS p_tr.(decls) in
        let i := INITS p_tr.(decls) in
        let c := p_tr.(tr).(chunk statement) in
        let asrt := PAssert p_tr.(res) in
        let clr := CLEARS p_tr.(decls) in
        ret < d ; i ;c ; asrt ; clr >
    | S_Seq s1 s2  => 
        s1_tr <- translate_c_statement env s1 ;;
        s2_tr <- translate_c_statement env s2 ;;
        ret < s1_tr ; s2_tr >

    | s => ret s
end.

(*
Definition translate_declarations (p: c_program) : c_program := 
    let fix f (x:Z) := x 
    
    in 
    mkPgrm p.(decls) p.(routines).


Notation "ψ ⟦ f ⟧ env" := (translate ψ f env) (at level 10). 


Inductive translate {T: Type} (env:ψ) : T -> T -> ψ -> Prop := 
    | program (P:T) : translate env P P ⊥.

 Notation "⟦ P ⟧" := (translate ⊥ P). (* mini-gmp program of P *)

Check ⟦ <[ fun int "test" (int "x", int "y") [int "x" ; skip] ]> ⟧.

Definition translate_function (f: c_routine) (p:Ψ) := True. 

 Compute (translate_declarations (mkPgrm nil (<[ fun int "test" (int "x", int "y") [int "x" ; <{ skip }>] ]>::nil))). 


Notation "Γ / ψ ⟦ p ⟧ " := translate_predicate Γ ψ p (at level 99). (* translation of predicate p in envs Γ ψ *)
Notation "ψ ⟦ f '⟧glob'" := (glob (translate ψ f)) (at level 99). 
Notation "ψ ⟦ f₁ ⟧ • ⟦ f₂ ⟧ " := (let ψ' := env (translate ψ f₁) in ψ' ⟦f₂⟧) (at level 99). (* Ψ' ⟦ f₂ ⟧ with Ψ' = ψ ⟦ f₁ ⟧ env *)
Reserved Notation "Γ / ψ ⟦ p '⟧.decl'" (at level 99). (* fresh variables generated by the translation *)
Reserved Notation "Γ / ψ ⟦ p '⟧.res'" (at level 99). (* variables containing the result *)
Reserved Notation "Γ / ψ ⟦ p '⟧.code'" (at level 99). (* generated code *)
*)