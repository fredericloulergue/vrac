Require Import RAC.Definitions.
Require Import RAC.Notations.
Require Import RAC.Utils.
Require Import String.
Require Import BinaryString.
Open Scope string_scope.
Open Scope mini_c_scope.
Require Import List.
Import ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Export CounterMonad.
Require Import ZArith.ZArith.

Open Scope mini_gmp_scope.

(* macro definitions *)

(* Definition Ï„_ASSGN (Ï„:gmp_t) v (e:c_exp) : statement := match ty e with
    | Mpz => < set_z(v,"e") >
    | C_Int => < set_i(v,"e") >
    | _ => Skip
end. *)


Definition mpz_ASSGN v (e:c_exp) : statement := match ty e with
    | Mpz => < set_z(v,"e") >
    | C_Int => < set_i(v,"e") >
    | _ => Skip
end.

Definition int_ASSGN v (e:c_exp) : statement := match ty e with
    | C_Int =>  <{ v = e }>
    | Mpz => < v = get_int("e") >
    | _ => Skip
end.

Definition Z_ASSGN (Ï„z:gmp_t) v z : statement := match Ï„z with
    | C_Int => <{ v = z }>
    | Mpz => < set_s(v,"s")>
    | _ => Skip
end.

Definition CMP c eâ‚ eâ‚‚ vâ‚ vâ‚‚ : statement := match ty eâ‚, ty eâ‚‚ with
    |  C_Int,C_Int => 
        <{ 
            if (eâ‚ < eâ‚‚) c = 0-1
            else if (eâ‚ > eâ‚‚) c = 1
            else c = 0
        }>
    | _,_ => 
        let a1 := mpz_ASSGN vâ‚ eâ‚ in 
        let a2 := mpz_ASSGN vâ‚‚ eâ‚‚ in
        < a1 ; a2 ; < c = cmp(vâ‚,vâ‚‚)> >
end
.


Definition binop_ASSGN(fsl_op:fsl_binop_int) (v:gmp_t â¨‰ ğ“¥) eâ‚ eâ‚‚ r vâ‚ vâ‚‚ : statement := 
    let (Ï„,c) := v in
    match Ï„,(ty eâ‚),(ty eâ‚‚) with
    | C_Int,C_Int,C_Int =>  let res := BinOpInt eâ‚ (â–¡ fsl_op) eâ‚‚ in <{ c = res }>
    | _,_,_ => 
        let s1 :=  mpz_ASSGN vâ‚ eâ‚ in
        let s2 :=  mpz_ASSGN vâ‚‚ eâ‚‚ in
        let s3 := match Ï„ with
                    | C_Int => <(op fsl_op r vâ‚ vâ‚‚) ; (int_ASSGN c r)>
                    | Mpz => op fsl_op c vâ‚ vâ‚‚
                    | _ => Skip
                    end
        in <s1;s2;s3>

    end
    .


Definition Ïˆ := ğ” â¨‰ (ğ” â‡€ ğ¼) â‡€ ğ“¥ . (* global definitions env *)

Definition Î“áµ¥ := ğ” â‡€ ğ“¥ â¨‰ ğ¼. (* correspondence binder -> variable and interval infered from it *)

Notation "'Î“' x" := (Î“áµ¥ x,Î“áµ¢ x) (at level 99).

Definition var_list := (gmp_t â¨‰ ğ“¥) âƒ°.


(* helper functions *)
Definition DECLS (vars:var_list)  : statement := (* generates declarations *)
    List.fold_right (fun (v:gmp_t â¨‰ ğ“¥) a => let (t,s) := v in   (*fixme t -> int*)
    <<[int s]> ; a>) Skip vars.

Definition INITS (vars : var_list) : statement := (* generates initialization *)
    List.fold_right 
    (
        fun (v:gmp_t â¨‰ ğ“¥) a => let (t,z) := v in 
        match t with
        | Mpz => <init(z) ; a>
        | C_Int | _  => a
        end        
    ) Skip vars.

Definition CLEARS (vars : var_list) : statement := (* generates deallocation *)
List.fold_right 
(
    fun (v:gmp_t â¨‰ ğ“¥) a => let (t,z) := v in 
    match t with
    | Mpz => <cl(z); a>
    | C_Int | _  => a
    end        
) Skip vars.



Record translation_result T: Type := mkTR
{
    chunk: T ;  (* code chunk  resulting of the translation *)
    env: Ïˆ; (* global definitions i.e. routines generated by the translation *)
    glob:c_decl âƒ° ; (* mini-c globals generated during translation *)
}.


Record translated_statement {T: Type} := mkSTR
{
    tr : translation_result T;
    decls: var_list ; (* fresh variables generated by the translation *)
    res: ğ“¥  ; (* variables containing the result *)
}.


Definition fresh_variable :=  c <- fresh ;; ret ("_v" ++ string_of_nat c)%string.

Fixpoint translate_predicate (e: Ïˆ) (p: predicate) : state := match p with
    | P_True => 
        c <- fresh_variable ;;
        let decl := [(Ctype C_Int,c)] in
        let code := <{ c = 1 }> in
        ret (mkSTR statement (mkTR statement code e nil) decl c)
    | P_False => 
        c <- fresh_variable ;; 
        let decl := [(Ctype C_Int,c)] in
        let code := <{ c = 0 }> in
        ret (mkSTR statement (mkTR statement code e nil) decl c)

    | Not t => 
        c <- fresh_variable ;; 
        p_tr <- translate_predicate e t ;;
        let _res := p_tr.(res) in
        let decl := (Ctype C_Int,c)::p_tr.(decls) in
        let code := S_Seq p_tr.(tr).(chunk statement) <{if _res c = 0 else c = 1 }> in
        ret (mkSTR statement (mkTR statement code p_tr.(tr).(env statement) nil) decl c)
    
    | Disj p1 p2 => 
        c <- fresh_variable ;;
        tr_p1 <- translate_predicate e p1;;
        let p1_res := tr_p1.(res) in
        let p1_code := tr_p1.(tr).(chunk statement) in
        tr_p2 <- translate_predicate tr_p1.(tr).(env statement) p2 ;;
        let p2_res := tr_p2.(res) in
        let p2_code := tr_p2.(tr).(chunk statement) in
        let decl := (Ctype C_Int,c)::tr_p1.(decls) ++ tr_p2.(decls) in
        let code := <p1_code; if p1_res c = 1 else <p2_code ; <{c = p2_res}>> > 
        in
        ret (mkSTR statement (mkTR statement code tr_p2.(tr).(env statement) nil) decl c)

    | P_BinOp t1 fsl_op t2 =>
        c <- fresh_variable ;;
        tr_t1 <- translate_term e t1 ;;
        let t1_code := tr_t1.(tr).(chunk statement) in
        tr_t2 <- translate_term tr_t1.(tr).(env statement) t2 ;;
        let t2_code := tr_t2.(tr).(chunk statement) in
        let decl := (Mpz, "v1")::(Mpz,"v2")::(Ctype C_Int,c)::tr_t1.(decls) ++ tr_t2.(decls) in
        let comp := CMP c tr_t1.(res) tr_t2.(res) "v1" "v2" in 
        let code := <t1_code ; t2_code; comp ; (Assign c (BinOpBool c (â—–fsl_op) 0))>  in
        ret (mkSTR statement (mkTR statement code tr_t2.(tr).(env statement) nil) decl c)

    | Call _ _ =>  let _ := translate_term in ret (mkSTR statement (mkTR statement Skip e nil) nil "") (* fixme : defined ? *)
end 

with translate_term (e: Ïˆ) (t : fsl_term) : state := match t with
    | T_Z z =>
        c <- fresh_variable ;;
        let decl := [(Ctype C_Int, c)] (*fixme *) in 
        let code := Z_ASSGN C_Int c z in
        ret (mkSTR statement (mkTR statement code e nil) decl c)

    | T_Id v => ret (mkSTR statement (mkTR statement Skip e nil) nil "")

    | T_BinOp t1 _op t2 => 
        let Ï„ := Ctype C_Int in (*fixme*)
        c <- fresh_variable ;;
        v1 <- fresh_variable ;;
        v2 <- fresh_variable ;;
        r <- fresh_variable ;;
        t1_tr <- translate_term e t1 ;; 
        let t1_code := t1_tr.(tr).(chunk statement) in
        let t1_res := t1_tr.(res) in
        t2_tr <- translate_term t1_tr.(tr).(env statement) t2 ;; 
        let t2_code := t2_tr.(tr).(chunk statement) in
        let t2_res := t2_tr.(res) in
        let decl := (Ï„,c) :: (Mpz,v1) :: (Mpz,v2) :: (Mpz,r) :: t1_tr.(decls) ++ t2_tr.(decls) in
        let assgn := binop_ASSGN _op (Ï„,c) t1_res t2_res r v1 v2 in
        let code := < t1_code ; t2_code ; assgn > in
        ret (mkSTR statement (mkTR statement code t2_tr.(tr).(env statement) nil) decl c)

    | Conditional p t1 t2 => 
        c <- fresh_variable ;;
        let Ï„ := Ctype C_Int in (*fixme*)
        p_tr <- translate_predicate e p ;;
        t1_tr <- translate_term p_tr.(tr).(env statement) t1 ;; 
        let t1_code := t1_tr.(tr).(chunk statement) in
        let t1_res := t1_tr.(res) in
        t2_tr <- translate_term t1_tr.(tr).(env statement) t2 ;; 
        let t2_code := t2_tr.(tr).(chunk statement) in
        let t2_res := t2_tr.(res) in
        let p_code  := p_tr.(tr).(chunk statement) in 
        let p_res := p_tr.(res) in
        let t1_assgn :=  int_ASSGN c t1_res (* fixme macros *) in
        let t2_assgn :=  int_ASSGN c t2_res (* fixme macros *) in
        let decl := (Ï„,c) :: p_tr.(decls) ++ t1_tr.(decls) ++ t2_tr.(decls) in
        let code := 
            <
                p_code;
                if (p_res) <{ 
                   t1_code ;
                   t1_assgn
                }> 
                else <{ 
                    t2_code ;
                    t2_assgn
                }>
            > in
        ret (mkSTR statement (mkTR statement code t2_tr.(tr).(env statement) nil) decl c)
    end
.
 


(* translation of statements *)
Fixpoint translate_c_statement (env: Ïˆ) (s : statement) : state := match s with
    | LAssert p  => 
        p_tr <- translate_predicate env p ;;
        let d := DECLS p_tr.(decls) in
        let i := INITS p_tr.(decls) in
        let c := p_tr.(tr).(chunk statement) in
        let asrt := PAssert p_tr.(res) in
        let clr := CLEARS p_tr.(decls) in
        ret < d ; i ;c ; asrt ; clr >
    | S_Seq s1 s2  => 
        s1_tr <- translate_c_statement env s1 ;;
        s2_tr <- translate_c_statement env s2 ;;
        ret < s1_tr ; s2_tr >

    | s => ret s
end.

(*
Definition translate_declarations (p: c_program) : c_program := 
    let fix f (x:Z) := x 
    
    in 
    mkPgrm p.(decls) p.(routines).


Notation "Ïˆ âŸ¦ f âŸ§ env" := (translate Ïˆ f env) (at level 10). 


Inductive translate {T: Type} (env:Ïˆ) : T -> T -> Ïˆ -> Prop := 
    | program (P:T) : translate env P P âŠ¥.

 Notation "âŸ¦ P âŸ§" := (translate âŠ¥ P). (* mini-gmp program of P *)

Check âŸ¦ <[ fun int "test" (int "x", int "y") [int "x" ; skip] ]> âŸ§.

Definition translate_function (f: c_routine) (p:Î¨) := True. 

 Compute (translate_declarations (mkPgrm nil (<[ fun int "test" (int "x", int "y") [int "x" ; <{ skip }>] ]>::nil))). 


Notation "Î“ / Ïˆ âŸ¦ p âŸ§ " := translate_predicate Î“ Ïˆ p (at level 99). (* translation of predicate p in envs Î“ Ïˆ *)
Notation "Ïˆ âŸ¦ f 'âŸ§glob'" := (glob (translate Ïˆ f)) (at level 99). 
Notation "Ïˆ âŸ¦ fâ‚ âŸ§ â€¢ âŸ¦ fâ‚‚ âŸ§ " := (let Ïˆ' := env (translate Ïˆ fâ‚) in Ïˆ' âŸ¦fâ‚‚âŸ§) (at level 99). (* Î¨' âŸ¦ fâ‚‚ âŸ§ with Î¨' = Ïˆ âŸ¦ fâ‚ âŸ§ env *)
Reserved Notation "Î“ / Ïˆ âŸ¦ p 'âŸ§.decl'" (at level 99). (* fresh variables generated by the translation *)
Reserved Notation "Î“ / Ïˆ âŸ¦ p 'âŸ§.res'" (at level 99). (* variables containing the result *)
Reserved Notation "Î“ / Ïˆ âŸ¦ p 'âŸ§.code'" (at level 99). (* generated code *)
*)