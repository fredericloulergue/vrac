Require Import RAC.Definitions.
Require Import RAC.Notations.
Require Import RAC.Utils.
Require Import String.
Require Import BinaryString.
Open Scope string_scope.
Open Scope mini_c_scope.
Require Import List.
Import ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Export CounterMonad.
Require Import ZArith.ZArith.
Require Import BinaryString.

Open Scope mini_gmp_scope.


(* macro definitions *)


Definition mpz_ASSGN v (e: gmp_exp ) : gmp_statement := match ty e with
    | T_Ext Mpz => match e with
                    | C_Id x _ => < set_z(v,x) >
                    | _ => Skip (* cannot happen *)
                    end
    | C_Int => < set_i(v,e) >
    | _ => Skip
end.

Definition int_ASSGN v (e: gmp_exp) : gmp_statement := match ty e with
    | T_Ext Mpz => match e with
                    | C_Id x _ => < v = get_int(x) >
                    | _ => Skip (* cannot happen *)
                    end
    
    | C_Int =>  <{ v = e }>
    | _ => Skip
end.

Definition τ_ASSGN t := match t with
    | T_Ext Mpz => mpz_ASSGN
    | C_Int => int_ASSGN
    | _ => int_ASSGN (* fixme  *)
    end.

Definition Z_ASSGN (τz:gmp_t) v (z:Z) : gmp_statement := match τz with
    | C_Int => <{ v = z }>
    | T_Ext Mpz => < set_s(v, (BinaryString.of_Z z) ) >
    | _ => Skip
end.




Definition CMP c e₁ e₂ v₁ v₂ : gmp_statement := match ty e₁, ty e₂ with
    |  C_Int,C_Int => 
        <{ 
            if (e₁ < e₂) c = 0-1
            else if (e₁ > e₂) c = 1
            else c = 0
        }>
    | _,_ => 
        let a1 := mpz_ASSGN v₁ e₁ in 
        let a2 := mpz_ASSGN v₂ e₂ in
        <{ a1 ; a2 ; < c = cmp(v₁,v₂)> }>
end
.


Definition binop_ASSGN (fsl_op:fsl_binop_int) (v:gmp_t ⨉ 𝓥) e₁ e₂ (r:id) v₁ v₂ : gmp_statement := 
    let (τ,c) := v in
    match τ,(ty e₁),(ty e₂) with
    | C_Int,C_Int,C_Int =>  let res := BinOpInt e₁ (□ fsl_op) e₂ in <{ c = res }>
    | _,_,_ => 
        let s1 :=  mpz_ASSGN v₁ e₁ in
        let s2 :=  mpz_ASSGN v₂ e₂ in
        let s3 := match τ with
             | C_Int => <{ < (op fsl_op r v₁ v₂) > ; < (int_ASSGN c (C_Id r Mpz)) > }>                    
             | T_Ext Mpz => op fsl_op c v₁ v₂
                    | _ => Skip
                    end
        in <{s1;s2;s3}>

    end
    .


Definition var_list := (gmp_t ⨉ 𝓥) ⃰.


(* helper functions *)
Definition DECLS (vars:var_list) : gmp_statement := (* generates declarations *)
    List.fold_right (
        fun (v:gmp_t ⨉ 𝓥) a => 
            let (t,s) := v in 
            let decl := C_Decl t s in <{ decl ; a}>
    ) Skip vars.

Definition INITS (vars : var_list) : gmp_statement := (* generates initialization *)
    List.fold_right 
    (
        fun (v:gmp_t ⨉ 𝓥) a => let (t,z) := v in 
        match t with
        | T_Ext Mpz => <{ < init(z) > ; a}>
        | C_Int  => a
        | _ => Skip
        end        
    ) Skip vars.

Definition CLEARS (vars : var_list) : gmp_statement := (* generates deallocation *)
List.fold_right 
(
    fun (v:gmp_t ⨉ 𝓥) a => let (t,z) := v in 
    match t with
    | T_Ext Mpz => <{ <cl(z)> ; a }>
    | C_Int | _  => a
    end        
) Skip vars.



Record translation_result T: Type := mkTR
{
    chunk: T ;  (* code chunk  resulting of the translation *)
    env: ψ; (* global definitions i.e. routines generated by the translation *)
    glob:gmp_decl ⃰ ; (* mini-c globals generated during translation *)
}.


Record translated_statement {T: Type} := mkSTR
{
    tr : translation_result T;
    decls: var_list ; (* fresh variables generated by the translation *)
    res: @_c_exp _gmp_t  ; (* variable containing the result *)
}.


Definition fresh_variable :=  c <- fresh ;;; ("_v" ++ string_of_nat c)%string. 

(* Since predicates are evaluated to 0 or 1, their result always fits in an int.*)


Fixpoint translate_predicate (bindings:Γᵥ) (t_inf : type_inf) (e: ψ) (p: predicate) : state  := match p with
    | P_True => 
        c <- fresh_variable ;;
        let decl := [(C_Int,c)] in
        let code := <{ c = 1 }> in
        ret (mkSTR gmp_statement (mkTR gmp_statement code e nil) decl (C_Id c C_Int))
    | P_False => 
        c <- fresh_variable ;; 
        let decl := [(C_Int,c)] in
        let code := <{ c = 0 }> in
        ret (mkSTR gmp_statement (mkTR gmp_statement code e nil) decl  (C_Id c C_Int))

    | Not p => 
        c <- fresh_variable ;; 
        p_tr <- translate_predicate bindings t_inf e p ;;;
        let _res := p_tr.(res) in
        let decl := (C_Int,c)::p_tr.(decls) in
        let code := <{ (p_tr.(tr).(chunk gmp_statement)) ; if _res c = 0 else c = 1 }> in
        mkSTR gmp_statement (mkTR gmp_statement code p_tr.(tr).(env gmp_statement) nil) decl (C_Id c C_Int)
    
    | Disj p1 p2 => 
        c <- fresh_variable ;;
        tr_p1 <- translate_predicate bindings t_inf e p1 ;;
        let p1_res := tr_p1.(res) in
        let p1_code := tr_p1.(tr).(chunk gmp_statement) in
        tr_p2 <- translate_predicate bindings t_inf tr_p1.(tr).(env gmp_statement) p2 ;;;
        let p2_res := tr_p2.(res) in
        let p2_code := tr_p2.(tr).(chunk gmp_statement) in
        let decl := (C_Int,c)::tr_p1.(decls) ++ tr_p2.(decls) in
        let code := <{ p1_code ; if p1_res c = 1 else <{ p2_code ; <{c = p2_res}> }> }> 
        in
        mkSTR gmp_statement (mkTR gmp_statement code tr_p2.(tr).(env gmp_statement) nil) decl  (C_Id c C_Int)

    | P_BinOp t1 fsl_op t2 =>
        c <- fresh_variable ;;
        tr_t1 <- translate_term bindings t_inf e t1 ;;
        let t1_code := tr_t1.(tr).(chunk gmp_statement) in
        tr_t2 <- translate_term bindings t_inf tr_t1.(tr).(env gmp_statement) t2 ;;
        let t2_code := tr_t2.(tr).(chunk gmp_statement) in
        let decl := (T_Ext Mpz, "v1")::(T_Ext Mpz,"v2")::(C_Int,c)::tr_t1.(decls) ++ tr_t2.(decls) in
        let comp := CMP c tr_t1.(res) tr_t2.(res) "v1" "v2" in 
        let code := <{ t1_code ; t2_code; comp ; (Assign c (BinOpBool (C_Id c C_Int) (◖fsl_op) 0)) }>  in
        ret (mkSTR gmp_statement (mkTR gmp_statement code tr_t2.(tr).(env gmp_statement) nil) decl  (C_Id c C_Int))

    | Call _ _ =>  let _ := translate_term in ret (mkSTR gmp_statement (mkTR gmp_statement Skip e nil) nil  (C_Id "" C_Int)) (* todo : same as fcall *)
end 

with translate_term (bindings : Γᵥ) (t_inf : type_inf) (e: ψ) (t : fsl_term) : state := match t with
    | T_Id v => let res := 
        match bindings v with (* warning : variable shadowing *)
        | Some x => fst x
        | None => v 
        end  in ret (mkSTR gmp_statement (mkTR gmp_statement Skip e nil) nil  (C_Id v C_Int))

    | T_Z z =>
        let τ := 𝚪 t_inf.(oracle) t_inf.(i_op) z t_inf.(t_env) in
        c <- fresh_variable ;;
        let decl := [(τ, c)]  in 
        let code := Z_ASSGN C_Int c z in
        ret (mkSTR gmp_statement (mkTR gmp_statement code e nil) decl (C_Id c C_Int))

    | T_BinOp t1 _op t2 => 
        let τ := 𝚪 t_inf.(oracle) t_inf.(i_op) (T_BinOp t1 _op t2) t_inf.(t_env) in
        c <- fresh_variable ;;
        v1 <- fresh_variable ;;
        v2 <- fresh_variable ;;
        r <- fresh_variable ;;
        t1_tr <- translate_term bindings t_inf e t1 ;; 
        let t1_code := t1_tr.(tr).(chunk gmp_statement) in
        let t1_res := t1_tr.(res) in
        t2_tr <- translate_term bindings t_inf t1_tr.(tr).(env gmp_statement) t2 ;; 
        let t2_code := t2_tr.(tr).(chunk gmp_statement) in
        let t2_res := t2_tr.(res) in
        let decl := (τ,c) :: (T_Ext Mpz,v1) :: (T_Ext Mpz,v2) :: (T_Ext Mpz,r) :: t1_tr.(decls) ++ t2_tr.(decls) in
        let assgn := binop_ASSGN _op (τ,c) t1_res t2_res r v1 v2 in
        let code := <{ t1_code ; t2_code ; assgn }> in
        ret (mkSTR gmp_statement (mkTR gmp_statement code t2_tr.(tr).(env gmp_statement) nil) decl (C_Id c C_Int))

    | T_Cond p t1 t2 => 
        c <- fresh_variable ;;
        let τ := 𝚪 t_inf.(oracle) t_inf.(i_op) (T_Cond p t1 t2) t_inf.(t_env) in
        p_tr <- translate_predicate bindings t_inf e p ;;
        t1_tr <- translate_term bindings t_inf p_tr.(tr).(env gmp_statement) t1 ;; 
        let t1_code := t1_tr.(tr).(chunk gmp_statement) in
        let t1_res := t1_tr.(res) in
        t2_tr <- translate_term bindings t_inf t1_tr.(tr).(env gmp_statement) t2 ;;;
        let t2_code := t2_tr.(tr).(chunk gmp_statement) in
        let t2_res := t2_tr.(res) in
        let p_code  := p_tr.(tr).(chunk gmp_statement) in 
        let p_res := p_tr.(res) in
        let t1_assgn := τ_ASSGN τ c t1_res in
        let t2_assgn := τ_ASSGN τ c t2_res in
        let decl := (τ,c) :: p_tr.(decls) ++ t1_tr.(decls) ++ t2_tr.(decls) in
        let code := 
            <{
                p_code;
                if (p_res) <{ 
                   t1_code ;
                   t1_assgn
                }> 
                else <{ 
                    t2_code ;
                    t2_assgn
                }>
            }> in
        mkSTR gmp_statement (mkTR gmp_statement code t2_tr.(tr).(env gmp_statement) nil) decl  (C_Id c C_Int)
    end

    
.
 
(* translation of statements *)
Fixpoint translate_statement (bindings : Γᵥ) (t_inf : type_inf) (env: ψ) (s : fsl_statement) : state := match s with
    | S_Ext (LAssert p)  => 
        p_tr <- translate_predicate bindings t_inf env p ;;;
        let d := DECLS p_tr.(decls) in
        let i := INITS p_tr.(decls) in
        let c := p_tr.(tr).(chunk gmp_statement) in
        let asrt := PAssert p_tr.(res) in
        let clr := CLEARS p_tr.(decls) in
         <{ d ; i ;c ; asrt ; clr }>
        
    | Seq s1 s2  => 
        s1_tr <- translate_statement bindings t_inf env s1 ;;
        s2_tr <- translate_statement bindings t_inf env s2 ;;;

        <{ s1_tr ; s2_tr }>
    | If e s1 s2 => 
        s1_tr <- translate_statement bindings t_inf env s1 ;;
        s2_tr <- translate_statement bindings t_inf env s2 ;;;
        If e s1_tr s2_tr
    | While e b =>  
        tr <- translate_statement bindings t_inf env b ;;; 
        While e tr

    | Assign id e => ret (Assign id e)
    | FCall x f args => ret (FCall x f args)

    | PAssert e => ret (PAssert e)
    | Return e => ret (Return e)
    | Decl d => ret (Decl d)
    | PCall id args => ret (PCall id args)
    | Skip => ret Skip
end.

(*

Definition translate_declarations (p: fsl_pgrm) : rac_pgrm := (* todo *) mkPgrm _gmp_statement _gmp_t nil nil.


Notation "ψ ⟦ f ⟧ env" := (translate ψ f env) (at level 10). 


Inductive translate {T: Type} (env:ψ) : T -> T -> ψ -> Prop := 
    | program (P:T) : translate env P P ⊥.

 Notation "⟦ P ⟧" := (translate ⊥ P). (* mini-gmp program of P *)

Check ⟦ <[ fun int "test" (int "x", int "y") [int "x" ; skip] ]> ⟧.

Definition translate_function (f: c_routine) (p:Ψ) := True. 

 Compute (translate_declarations (mkPgrm nil (<[ fun int "test" (int "x", int "y") [int "x" ; <{ skip }>] ]>::nil))). 


Notation "Γ / ψ ⟦ p ⟧ " := translate_predicate Γ ψ p (at level 99). (* translation of predicate p in envs Γ ψ *)
Notation "ψ ⟦ f '⟧glob'" := (glob (translate ψ f)) (at level 99). 
Notation "ψ ⟦ f₁ ⟧ • ⟦ f₂ ⟧ " := (let ψ' := env (translate ψ f₁) in ψ' ⟦f₂⟧) (at level 99). (* Ψ' ⟦ f₂ ⟧ with Ψ' = ψ ⟦ f₁ ⟧ env *)
Reserved Notation "Γ / ψ ⟦ p '⟧.decl'" (at level 99). (* fresh variables generated by the translation *)
Reserved Notation "Γ / ψ ⟦ p '⟧.res'" (at level 99). (* variables containing the result *)
Reserved Notation "Γ / ψ ⟦ p '⟧.code'" (at level 99). (* generated code *)



(* rightswiggarrow ⇝ *)


*)