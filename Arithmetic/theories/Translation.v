From Coq Require Import List String BinaryString ZArith Structures.OrdersEx Wellfounded.Lexicographic_Product.
From MMaps Require Import MMaps.
From RecordUpdate Require Import RecordUpdate.
From Equations Require Import Equations.
From RAC Require Import Utils Environnement Macros Oracle.
From RAC.Languages Require Import Syntax Semantics.

Import ListNotations.
Import RecordSetNotations.


Module TM := TranslationMonad. 
Module TMNotations := MonadNotations(TM).
Module TMOps := MonadOps(TM).
Import TMNotations.

#[local] Open Scope string_scope.
#[local] Open Scope mini_c_scope.
#[local] Open Scope list_scope.
#[local] Open Scope Z_scope.
#[local] Open Scope mini_gmp_scope.
#[local] Open Scope utils_scope.




Definition var_list := (𝓥 ⨉ gmp_t)*.

(* helper functions *)
Definition DECLS (vars:var_list) : list gmp_decl := (* generates declarations *)
    List.fold_right (
        fun (v:𝓥 ⨉ _) decls  => 
            let (s,t) := v in 
            (C_Decl t s) :: decls
    ) [] vars .

Definition INITS (vars : var_list) : gmp_statement := (* generates initialization *)
    List.fold_right 
    (
        fun (v:𝓥 ⨉ _) a => let (z,t) := v in 
        match t with
        | C_Int => a
        | T_Ext Mpz => 
            let init : gmp_statement  := <( init(z) )> in 
            <{init ; a}>  
        | _ => Skip (* cannot happen  *)
        end      
    ) Skip vars.

Definition CLEARS (vars : var_list) : gmp_statement := (* generates deallocation *)
List.fold_right 
(
    fun (v:𝓥 ⨉ _) a => let (z,t) := v in 
    match t with
    | T_Ext Mpz =>
        let cl : gmp_statement := <( cl(z) )> in 
        <{cl  ; a }>
    | C_Int | _  => a
    end        
) Skip vars.



Module Translation (Oracle : Oracle).
    Import Oracle.

    Definition Γᵥ := StringMap.t (𝓥 ⨉ 𝐼). (* environment for logic bindings : variable and interval infered from it *)


    Definition Γ := Γᵥ ⨉ Γᵢ.
    Notation "'Γ' '(' x ')' " := (Γᵥ x, Γᵢ x).


    Module 𝐼_as_OT <: OrderedType := PairOrderedType(Z_as_OT)(Z_as_OT).  
    (* maps of ordered maps over ordered type are ordered *)
    Module TypingEnv_as_OT <: OrderedType := StringMap.Decidable(𝐼_as_OT).
    (* we get an ordered type for the product of 𝔏 and  StringMap.t *)
    Module String_TypingEnv_as_OT <: OrderedType := PairOrderedType(String_as_OT)(TypingEnv_as_OT).
    (* finally, we get our environnement of global definitions *)
    Module GlobalDef := MMapsEnv(String_TypingEnv_as_OT).

    Definition ψ : Type :=  GlobalDef.t 𝓥.  (* ψ(id,tenv) returns the name of the specialized version of [id] for [tenv] *)

    Definition nat_lexico := slexprod nat nat Nat.lt Nat.lt.


    Record translation_result {T : Type} := mkTR
    {
        chunk: T ;  (* code chunk  resulting of the translation *)
        tenv: ψ; (* global definitions i.e. routines generated by the translation *)
        glob:gmp_routine*; (* mini-c globals generated during translation (global var + routine) *)
    }.
    #[export] Instance etaTR {T : Type}: Settable _ := settable! (mkTR T) <chunk;tenv;glob>.


    Record translated_statement {T: Type} := mkSTR
    {
        tr : @translation_result T;

        (* fresh variables generated by the translation *)
        decls: var_list ;

        (* variable containing the result *)
        (* can't just be the varname because CMP expects an expression as 2nd and 3rd param 
            so we need both the id and type.
            Even though we only use C_Int most of the time, the oracle outputs gmp_t so it must be gmp_t
        *)
        res: 𝓥  ⨉ gmp_t;
    }.
    #[export] Instance etaSTR {T : Type}: Settable _ := settable! (mkSTR T) <tr;decls;res>.

    Definition fresh_variable :=  c <- TM.fresh ;;; ("_v" ++ string_of_nat c)%string. 

    Definition fresh_fname id :=  c <- TM.fresh ;;; ("_id" ++ id ++ string_of_nat c)%string. 



    Section MutRec.
        Set Equations Transparent.
        Set Universe Polymorphism.
        Import Nat.


        Inductive logic_tr_proto : forall (A B C D E : Type), (A -> B -> C -> D -> E -> Type) -> Set :=
        | tr_pred : logic_tr_proto (@fenv _fsl_statement Empty_set) Γᵥ Γᵢ ψ predicate (fun _ _ _ _ _ => @TM.t (@translated_statement gmp_statement))
        | tr_term : logic_tr_proto (@fenv _fsl_statement Empty_set) Γᵥ Γᵢ ψ fsl_term (fun _ _ _ _ _ => @TM.t (@translated_statement gmp_statement))
        | f_gen : logic_tr_proto (@fenv _fsl_statement Empty_set) Γᵥ Γᵢ ψ id (fun _ _ _ _ _ =>  @TM.t (@translation_result 𝓥))
        .

        Derive Signature NoConfusion for logic_tr_proto.

        Import Sigma_Notations.


        Definition args_size {A : Type} (size:A -> nat) (l:list A) := (fold_right (fun a s => size a + s) 0 l)%nat.

        Definition args_size_lt_in : forall (A:Type) (l:list A) (f : A -> nat) (a:A), 
            List.In a l -> (f a < S (args_size f l))%nat.
        Proof. Open Scope nat.
            intros A l f a Hin. unfold args_size. induction l.
            - inversion Hin.
            - simpl in *. destruct Hin.
                *  subst. now auto with arith.
                *  apply IHl in H. clear IHl. simpl. rewrite Nat.add_comm.  auto with arith.
        Qed. 

        Fixpoint term_size (t : fsl_term) : nat :=
            match t with
            | T_Z _ | T_Id _ _  => 1
            | T_BinOp l _ r => S (term_size l) + (term_size r)
            | T_Cond p t e => S (term_size t) + (term_size e) + (pred_size p)
            | T_Call _ args => S (args_size term_size args)
        end
        with pred_size (p : predicate) :=  match p with
            | P_True | P_False => 1
            | P_Not x => S (pred_size x)
            | P_BinOp l _ r  => S (term_size l) + (term_size r)
            | P_Disj l r => S (pred_size l) + (pred_size r)
            | P_Call _ args =>  S (args_size term_size args)
        end.


        (* todo: upper bound of ψ is the number of logic functions times the number of environnment for bindings *)
        Definition Ψ_max (fenv: @fenv _fsl_statement Empty_set) (g:Γᵢ) :=  
            (Nat.mul (StringMap.cardinal fenv.(lfuns)) (StringMap.cardinal g)).




        Equations measure : (Σ A B C D E P (_ : A) (_ : B) (_ : C) (_ : D) (_ : E), logic_tr_proto A B C D E P) -> nat ⨉ nat :=
            | (_,_,_,_,_,_, f_env,_,t_env,g,p,tr_pred) =>  pair 1 (pred_size p)
            | (_,_,_,_,_,_, f_env,_,t_env,g,t,tr_term) => pair 1 (term_size t)
            | (_,_,_,_,_,_, f_env,_,t_env,g,fname,f_gen)  =>  pair (GlobalDef.cardinal g) 0
        .


        Definition rel := Program.Wf.MR nat_lexico measure.
        #[global] Instance: WellFounded rel.
        Proof.
            red. apply Wf.measure_wf. apply wf_slexprod; apply Wf_nat.lt_wf. 
        Defined.


        (* pack take the function and all its arguments *)
        Definition pack {A B C D E} {P} (x1 : A) (x2 : B) (x3 : C) (x4 : D) (x5 : E) (t : logic_tr_proto A B C D E P) :=
            (A,B,C,D,E,P, x1, x2, x3, x4, x5, t) : (Σ A B C D E P (_ : A) (_ : B) (_ : C) (_ : D) (_ : E), logic_tr_proto A B C D E P).

    End MutRec.

    Notation "x 'eqn:' p" := (exist _ x p) (only parsing, at level 20).

    Hypothesis fixme : forall (last_env:ψ),  (Nat.lt (GlobalDef.cardinal last_env) 1 /\ Nat.lt 1 (GlobalDef.cardinal last_env)).


    Local Obligation Tactic := 
    simpl in *; Tactics.program_simplify; CoreTactics.equations_simpl; try Tactics.program_solve_wf ;
    red ;red ; cbn ;  try (constructor 2; auto with arith); try now apply args_size_lt_in.
    
    Equations? translate_fsl {A B C D E} {P} (t : logic_tr_proto A B C D E P) (f : A) (bindings:B) (t_env:C) (e: D) (x : E)  
        : P f bindings t_env e x by wf (pack f bindings t_env e x t) rel  := 

    (* predicate translation *)

    | tr_pred , _, _ , _ , _ , P_True => 
            c <- fresh_variable ;;
            let decl := [(c,C_Int)] in
            let code := <{ c = 1 }> in
            TM.ret (mkSTR gmp_statement (mkTR gmp_statement code e nil) decl (c,C_Int))

    | tr_pred , _, _ , _ , _ , P_False => 
            c <- fresh_variable ;; 
            let decl := [(c,C_Int)] in
            let code := <{ c = 0 }> in
            TM.ret (mkSTR gmp_statement (mkTR gmp_statement code e nil) decl  (c, C_Int))

    | tr_pred , _, _ , _ , _ , P_Not p =>             
            c <- fresh_variable ;; 
            p_tr <- translate_fsl tr_pred f bindings t_env e p ;;;
            let _res := C_Id (fst p_tr.(res)) (snd p_tr.(res)) in
            let decl := (c,C_Int)::p_tr.(decls) in
            let code := <{ (p_tr.(tr).(chunk gmp_statement)) ; if _res c = 0 else c = 1 }> in
            mkSTR gmp_statement (mkTR gmp_statement code p_tr.(tr).(tenv gmp_statement) nil) decl (c, C_Int)
        
    | tr_pred , _, _ , _ , _ , P_Disj p1 p2 => 
            c <- fresh_variable ;;
            tr_p1 <- translate_fsl tr_pred f bindings t_env e p1 ;;
            let p1_res := C_Id (fst tr_p1.(res)) (snd tr_p1.(res)) in
            let p1_code := tr_p1.(tr).(chunk gmp_statement) in
            tr_p2 <- translate_fsl tr_pred f bindings t_env tr_p1.(tr).(tenv gmp_statement) p2 ;;;
            let p2_res := C_Id (fst tr_p2.(res)) (snd tr_p2.(res)) in
            let p2_code := tr_p2.(tr).(chunk gmp_statement) in
            let decl := (c,C_Int)::tr_p1.(decls) ++ tr_p2.(decls) in
            let code := <{ p1_code ; if p1_res c = 1 else <{ p2_code ; <{c = p2_res}> }> }> 
            in
            mkSTR gmp_statement (mkTR gmp_statement code tr_p2.(tr).(tenv gmp_statement) nil) decl  (c,C_Int)

    | tr_pred , _, _ , _ , _ , P_BinOp t1 fsl_op t2 =>            
            c <- fresh_variable ;;
            tr_t1 <- translate_fsl tr_term f bindings t_env e t1 ;;
            let t1_code := tr_t1.(tr).(chunk gmp_statement) in
            tr_t2 <- translate_fsl tr_term f bindings t_env tr_t1.(tr).(tenv gmp_statement) t2 ;;
            let t2_code := tr_t2.(tr).(chunk gmp_statement) in

            let decl := ("v1", T_Ext Mpz)::("v2",T_Ext Mpz)::(c,C_Int)::tr_t1.(decls) ++ tr_t2.(decls) in

            let (ct1,tt1) := tr_t1.(res) in 
            let (ct2,tt2) := tr_t1.(res) in 
            let comp := CMP c (C_Id ct1 tt1) (C_Id ct2 tt2) "v1" "v2" in 

            let code := <{ t1_code ; t2_code; comp ; (Assign c (BinOpBool (C_Id c C_Int) (◖fsl_op) 0)) }>  in
            TM.ret (mkSTR gmp_statement (mkTR gmp_statement code tr_t2.(tr).(tenv gmp_statement) []) decl  (c,C_Int))

    | tr_pred , _, _ , _ , _ , P_Call pname args  =>  
        match Logic.inspect (StringMap.find pname f.(preds)) with
        | None eqn:_ =>  TM.error

        | Some (params,_) eqn:HInpreds  => 

            (* value returned by the function call *)
            c <- fresh_variable ;;

            (* for each pair of function argument and parameter *)
            f_res <- fold_left2_in args params ( fun 
                (done: @TM.t (var_list ⨉ list _c_exp ⨉ translation_result ⨉ StringMap.t (id ⨉ 𝐼))) 
                (arg : {x | In x args})
                (param : {x : 𝔏 | In x params}) => 

                let HInpreds := HInpreds in

                done <- done ;;


                (* 
                    for some reason, equations fails to prove functional induction if using let patterns 
                    (even with annotation).

                    it also required to add explicit types to the function parameters of fold_left2_in as well as  
                    trading the `with clause` for the regular match. The `let HInpreds := HInpreds in` 
                    propagates the knowledege that `pname` is in `f.(preds)`

                let '(curr_decls,curr_args_ids,curr_tr,binds)  := done  in   *)


                (* get current declarations, translation and bindings environment *)
                let curr_decls := fst (fst (fst (done))) in
                let curr_args_ids := snd (fst (fst done)) in
                let curr_tr := snd (fst done) in
                let binds := snd done in


                (* translate the argument *)
                t_tr <- translate_fsl tr_term f bindings t_env curr_tr.(tenv) (proj1_sig arg) ;;

                let new_tr := curr_tr 
                    <| tenv := t_tr.(tr).(tenv) |> (* pass the updated env *)
                    <| chunk ::= fun s => Seq s t_tr.(tr).(chunk) |> (* append the code generated by the translation of t*)
                    <| glob ::= fun globs => app globs t_tr.(tr).(glob) |> (* append the new globals *)
                in 

                (* building the fresh binding env for parameters *)
                v <- fresh_variable ;;;
                let interval := 𝓘 (proj1_sig arg) t_env in

                (* collect and append  *)
                ( 
                    curr_decls ++ t_tr.(decls), (* the new fresh variables from the translation of the argument *)
                    curr_args_ids ++ [C_Id (fst t_tr.(res)) (snd t_tr.(res))], (* the variable used to represent the argument *)
                    new_tr, (* the updated function translation  *)
                    StringMap.add (proj1_sig param) (v,interval) binds (* the updated bindings *)
                ) 

            ) (TM.ret ([(c,C_Int)], ([] : list _c_exp), mkTR gmp_statement Skip e [], StringMap.empty)) 
            
            ;;

            let '(decls,params_id,f_tr,binds) := f_res in 
            
            (* last env needed for function generation *)
            let last_env := f_tr.(tenv) in 

            (* get specialized function name, env and globals  *)
            gf <- match GlobalDef.find (pname,t_env) e with
            (* function already exists for current binders, no generation required, 
                env is the same as the current one 
                no new globals 
            *)
            | Some name => TM.ret (name,e,[]) 
            | None => (* no function specialized for those binders, generate a new one *)
                new_f <- translate_fsl f_gen f binds t_env last_env pname ;;;
                (* one new global : the function declaration itself *)
                (new_f.(chunk), new_f.(tenv), new_f.(glob))
            end ;;;

            let '(gf_name,gf_env,gf_globs) := gf in  
            
            (* append function globals to the globals *)
            let globs := f_tr.(glob) ++ gf_globs in

            (* return value *)
            let res := (c,C_Int) (* c is int because return value is either 0 or 1 *) in 

            (* create calling code *)
            let code := PCall gf_name params_id in

            mkSTR gmp_statement (mkTR _ code gf_env globs) decls res
        end
        

    (* term translation *)

    | tr_term , _, _ , _ , _ , T_Id v FSL_Int => 
         (* program variable *)
        TM.ret (mkSTR gmp_statement (mkTR gmp_statement Skip e nil) nil (v,C_Int))

    | tr_term , _, _ , _ , _ , T_Id v FSL_Integer with StringMap.find v bindings => (* logic var *)
        {
            | Some (x,i) => 
                TM.ret (mkSTR gmp_statement (mkTR gmp_statement Skip e nil) nil (x,ϴ i))
            | None => TM.error
        } 

    | tr_term , _, _ , _ , _ , T_Z z =>
            let τ := 𝒯 z t_env in
            c <- fresh_variable ;;
            let decl := [(c,τ)]  in 
            let code := Z_ASSGN C_Int c z in
            TM.ret (mkSTR gmp_statement (mkTR gmp_statement code e nil) decl (c,C_Int))

    | tr_term , _, _ , _ , _ , T_BinOp t1 _op t2 =>
            let τ := 𝒯 (T_BinOp t1 _op t2) t_env in
            c <- fresh_variable ;;
            v1 <- fresh_variable ;;
            v2 <- fresh_variable ;;
            r <- fresh_variable ;;
            t1_tr <- translate_fsl tr_term f bindings t_env e t1  ;; 
            let t1_code := t1_tr.(tr).(chunk gmp_statement) in
            let t1_res := C_Id (fst t1_tr.(res)) (snd t1_tr.(res)) in
            t2_tr <- translate_fsl tr_term f bindings t_env t1_tr.(tr).(tenv gmp_statement) t2  ;; 
            let t2_code := t2_tr.(tr).(chunk gmp_statement) in
            let t2_res :=  C_Id (fst t2_tr.(res)) (snd t2_tr.(res)) in
            let decl := (c,τ) :: (v1,T_Ext Mpz) :: (v2,T_Ext Mpz) :: (r,T_Ext Mpz) :: t1_tr.(decls) ++ t2_tr.(decls) in
            let assgn := binop_ASSGN _op (c,τ) t1_res t2_res r v1 v2 in
            let code := <{ t1_code ; t2_code ; assgn }> in
            TM.ret (mkSTR gmp_statement (mkTR gmp_statement code t2_tr.(tr).(tenv gmp_statement) nil) decl (c,C_Int))

    | tr_term , _, _ , _ , _ ,T_Cond p t1 t2 =>
            c <- fresh_variable ;;
            let τ := 𝒯  (T_Cond p t1 t2) t_env in
            p_tr <- translate_fsl tr_pred f bindings t_env e p ;;
            t1_tr <- translate_fsl tr_term f bindings t_env p_tr.(tr).(tenv gmp_statement) t1  ;; 
            let t1_code := t1_tr.(tr).(chunk gmp_statement) in
            let t1_res := C_Id (fst t1_tr.(res)) (snd t1_tr.(res))  in
            t2_tr <- translate_fsl tr_term f bindings t_env t1_tr.(tr).(tenv gmp_statement) t2  ;;;
            let t2_code := t2_tr.(tr).(chunk gmp_statement) in
            let t2_res := C_Id (fst t2_tr.(res)) (snd t2_tr.(res)) in
            let p_code  := p_tr.(tr).(chunk gmp_statement) in 
            let p_res := C_Id (fst p_tr.(res)) (snd p_tr.(res)) in
            let t1_assgn := τ_ASSGN τ c t1_res in
            let t2_assgn := τ_ASSGN τ c t2_res in
            let decl := (c,τ) :: p_tr.(decls) ++ t1_tr.(decls) ++ t2_tr.(decls) in
            let code := 
                <{
                    p_code;
                    if (p_res) <{ t1_code ; t1_assgn}> 
                    else <{t2_code ; t2_assgn }>
                }> in
            mkSTR gmp_statement (mkTR gmp_statement code t2_tr.(tr).(tenv gmp_statement) nil) decl  (c,C_Int)

    | tr_term , _, _ , _ , _ , T_Call fname args with Logic.inspect (StringMap.find fname f.(lfuns)) =>  
        {
            | None eqn:_ => TM.error

            | Some (params,_) eqn:HInlfuns =>

                let rtype :=  𝒯 (T_Call fname args) t_env in 
                
                (* value returned by the function call *)
                c <- fresh_variable ;;

                (* for each pair of function argument and parameter *)
                f_res <- fold_left2_in args params ( fun 
                    (done: @TM.t (var_list ⨉ list _c_exp ⨉ translation_result ⨉ StringMap.t (id ⨉ 𝐼))) 
                    (arg : {x | In x args})
                    (param : {x : 𝔏 | In x params}) => 

                    done <- done ;;



                    (* get current declarations, translation and bindings environment *)
                    let '(curr_decls,curr_args_ids,curr_tr, binds) := done : (_ ⨉ _ ⨉ _) in 
                    (* let curr_decls := fst (fst (fst (done))) in
                    let curr_args_ids := snd (fst (fst done)) in
                    let curr_tr := snd (fst done) in
                    let binds := snd done in *)


                    (* translate the argument *)
                    t_tr <- translate_fsl tr_term f bindings t_env curr_tr.(tenv) (proj1_sig arg) ;;

                    let new_tr := curr_tr 
                        <| tenv := t_tr.(tr).(tenv) |> (* pass the updated env *)
                        <| chunk ::= fun s => Seq s t_tr.(tr).(chunk) |> (* append the code generated by the translation of t*)
                        <| glob ::= fun globs => app globs t_tr.(tr).(glob) |> (* append the new globals *)
                    in 

                    (* building the fresh binding env for parameters *)
                    v <- fresh_variable ;;;
                    let interval := 𝓘 (proj1_sig arg) t_env  in

                    (* collect and append  *)
                    ( 
                        curr_decls ++ t_tr.(decls), (* the new fresh variables from the translation of the argument *)
                        curr_args_ids ++ [C_Id (fst t_tr.(res)) (snd t_tr.(res))], (* the variable used to represent the argument *)
                        new_tr, (* the updated function translation  *)
                        StringMap.add (proj1_sig param) (v,interval) binds (* the updated bindings *)
                    )

                ) (TM.ret ([(c,rtype)], ([] : list _c_exp), mkTR gmp_statement Skip e [], StringMap.empty)) 

                ;;

                let '(decls,params_id,f_tr,binds) := f_res in 
                
                (* last env needed for function generation *)
                let last_env := f_tr.(tenv) in 

                (* get specialized function name, env and globals  *)
                gf <- match GlobalDef.find (fname,t_env) e with
                (* function already exists for current binders, no generation required, 
                    env is the same as the current one 
                    no new globals 
                *)
                | Some name => TM.ret (name,e,[]) 
                | None => (* no function specialized for those binders, generate a new one *)
                    new_f <- translate_fsl f_gen f binds t_env last_env fname ;;;
                    (* one new global : the function declaration itself *)
                    (new_f.(chunk), new_f.(tenv), new_f.(glob))
                end ;;

                let '(gf_name,gf_env,gf_globs) := gf in  
                
                (* append function globals to the globals *)
                let globs := f_tr.(glob) ++ gf_globs in

                (* return value *)
                let res := (c,C_Int) (*fixme : what type is c ? *) in 

                (* create calling code *)
                code  <- match rtype with
                    | C_Int => TM.ret (FCall c gf_name params_id)
                    | T_Ext (Mpz) => 
                        let firstparam := C_Id (fst res) (snd res) in 
                        TM.ret (PCall gf_name (firstparam :: params_id))
                    | _ => TM.error
                end ;;;
                
                mkSTR gmp_statement (mkTR _ code gf_env globs) decls res
        }


    (* function generation *)
                
    | f_gen, _,_,_,_,fname with Logic.inspect (StringMap.find fname f.(lfuns)) =>
        {
            | None eqn:_ => TM.error

            | Some (params,b) eqn:HInlfuns => 
            (* get the return type *)
                let rtype := 𝒯 b t_env in

                (* generate a fresh name for the new function *)
                fres <- fresh_fname fname;;

                (* process body *)

                tr_b <- translate_fsl tr_term f bindings t_env e b ;;

                (* global declarations generated by the body , appended before function declaration  *)
                let globals := tr_b.(tr).(glob) in

                (* prepare env update : 
                    indexed by the original name of the function and what binders interval Γᵢ it is for ;
                    returns the unique generated function id for those binders
                *)
                let upd_binding := GlobalDef.add (fname,t_env) fres in

                let new_env := upd_binding tr_b.(tr).(tenv) in        

                (* in case the result is too big to fit in a machine integer *)
                let retvar := "_ret" in

            (*  build the signature of the function *)
            signature <- (
                (* figure out the type and id of parameters *)
                params <- TMOps.map (fun p => 
                    i <- match StringMap.find p t_env with
                        | Some i => TM.ret i 
                        | None => TM.error
                        end ;;
                    (* get the corresponding id *)
                    v <- match StringMap.find p bindings with 
                        | Some (v,_) => TM.ret v  
                        | None => TM.error
                        end 
                    ;;;
                    C_Decl (ϴ i) v
                ) params ;; 

                match rtype with
                | C_Int => 
                    TM.ret (PFun C_Int fres params)
                | T_Ext Mpz  => 
                    (* if rtype is mpz, pass function result using first argument *)
                    TM.ret (PFun Void fres ((C_Decl (T_Ext Mpz) retvar)::params))
                | _ => TM.error
                end 
            ) ;;
            
            (* build the body *)
            (* reprocess body with original ψ + new f entry *)
            tr_b <- translate_fsl tr_term f bindings t_env (upd_binding e) b;;;

            let '(body_res_id,body_res_ty) as bres := tr_b.(res) in 
            (* body epilogue *)
            let bdecls := DECLS [bres] in
            let inits := INITS [bres] in 

            let code := tr_b.(tr).(chunk) in
            
            let rv := (C_Id body_res_id body_res_ty) in
            let cl := CLEARS [bres] in
            (* body prologue *)
            let ret_and_cleanup := match rtype with
            | C_Int =>  <{ cl ; return rv}>
            | T_Ext Mpz => 
                let setret : gmp_statement := Set_z retvar body_res_id
                in <{ setret ;  cl }>
            | _ => Skip end 
            in
            let body := <{ inits ; code ; ret_and_cleanup }> in 
            let gen_f := signature bdecls body in
            mkTR _ fres new_env (globals++[gen_f]) (* function declarations is put with the other globals *)
        }   
    .
    
    - constructor. apply fixme.
    - constructor. apply fixme.
    - constructor.  apply fixme.
    - constructor. apply fixme.
    Qed.

    (* Solve Obligations with 
        unshelve (simpl in *; Tactics.program_simplify; CoreTactics.equations_simpl; try Tactics.program_solve_wf; 
        red ;red ; cbn ;  try (constructor 2; auto with arith); try now apply args_size_lt_in. *)


    Definition translate_term := translate_fsl tr_term.
    Definition translate_pred := translate_fsl tr_pred.

    
    Definition c_decl_to_gmp_decl (d:@_c_decl Empty_set) : gmp_decl := 
        let '(C_Decl t id) := d in C_Decl (c_t_to_gmp_t t) id
    .

    Set Printing Implicit.
    (* translation of statements *)
    Fixpoint translate_statement (f:fenv) (bindings : Γᵥ) (t_env:Γᵢ) (env: ψ) (s : fsl_statement) : @TM.t (@translation_result gmp_statement) := 
        match s with
        | S_Ext (LAssert p)  => 
            p_tr <- translate_fsl tr_pred f bindings t_env env p;;;
            let d := DECLS p_tr.(decls) in
            let i := INITS p_tr.(decls) in
            let c := p_tr.(tr).(chunk gmp_statement) in
            let res := C_Id (fst p_tr.(res)) (snd p_tr.(res)) in
            let asrt := PAssert res in
            let clr := CLEARS p_tr.(decls) in 
            p_tr.(tr) 
                <| chunk := (GMP_Scope d <{i ;c ; asrt ; clr }> : gmp_statement) |> 
                (* Before, we propagated declarations global declarations
                    because the syntax forbids declarations to be put in a statement.
                    It was a hack that required a different treatement inside translate_program might not have been correct.
                    Now, with GMP_Scope added to the gmp syntax, this is not necessary.

                    <| glob ::= fun l => l ++ (map GDecl d) |>
                *)            
        
        | FCall x f args => 
            let args := map c_exp_to_gmp_exp args in 
            TM.ret (mkTR gmp_statement (FCall x f args) env nil)


        | Seq s1 s2  => 
            s1_tr <- translate_statement f bindings t_env env s1 ;;
            s2_tr <- translate_statement f bindings t_env s1_tr.(tenv) s2 ;;;
            s2_tr <| chunk := Seq s1_tr.(chunk) s2_tr.(chunk) |> <| glob ::= app s1_tr.(glob) |>

        | If e s1 s2 => 
            let e := c_exp_to_gmp_exp e in 
            s1_tr <- translate_statement f bindings t_env env s1 ;;
            s2_tr <- translate_statement f bindings t_env s1_tr.(tenv) s2 ;;;
            s2_tr <| chunk := If e s1_tr.(chunk) s2_tr.(chunk) |> <| glob ::= app s1_tr.(glob) |>

        | While e b =>  
            let e := c_exp_to_gmp_exp e in 
            tr <- translate_statement f bindings t_env env b ;;; 
            tr <| chunk := (While e tr.(chunk)) |>

        | Assign id e => TM.ret (mkTR gmp_statement (Assign id (c_exp_to_gmp_exp e)) env nil)

        | PAssert e => 
            let e := c_exp_to_gmp_exp e in 
            TM.ret (mkTR gmp_statement (PAssert e) env nil)
        | Return e => 
            let e := c_exp_to_gmp_exp e in 
            TM.ret (mkTR gmp_statement (Return e) env nil)
        | PCall id args => let args := map c_exp_to_gmp_exp args in TM.ret (mkTR gmp_statement (PCall id args) env nil)
        | Skip => TM.ret (mkTR gmp_statement Skip env nil)
    end.


    Definition build_fenv (routines: list fsl_routine) : @fenv _fsl_statement Empty_set := 
        let extract_c_args : _c_decl* -> 𝓥* := List.map (fun d => let 'C_Decl _ x := d in x) in
        let extract_fsl_args : fsl_decl*-> 𝓥* := List.map (fun d => let 'FSL_Decl _ x := d in x) in
        List.fold_left (fun fenv r => 
        match r with 
        | PFun rtype name args _ body => 
            match rtype with 
            | Void => 
                (* procedure *)
                {|  funs := fenv.(funs); 
                    procs := StringMap.add name (extract_c_args args,body) fenv.(procs); 
                    lfuns := fenv.(lfuns); 
                    preds := fenv.(preds)
                |}
            | C_Int =>  
                (* function *)
                {|  funs := StringMap.add name (extract_c_args args,body) fenv.(funs); 
                    procs := fenv.(procs); 
                    lfuns := fenv.(lfuns); 
                    preds := fenv.(preds)
                |}
            | T_Ext _ => 
                (* PFun can't have T_Ext rtype *)
                fenv
            end
        | F_Ext (LFun rtype name args body) => 
            (* logic function *)
            {|  funs := fenv.(funs); 
                procs := fenv.(procs); 
                lfuns := StringMap.add name (extract_fsl_args args,body) (fenv.(lfuns) : StringMap.t (𝓥 * ⨉ ℨ)); 
                preds := fenv.(preds)
            |}

        | F_Ext (Predicate name args body) => 
            (* predicate *)
            {|
                funs := fenv.(funs); 
                procs := fenv.(procs); 
                lfuns := fenv.(lfuns); 
                preds := StringMap.add name (extract_fsl_args args,body) fenv.(preds)
            |}
        end
        ) routines {|funs := StringMap.empty ; 
                    procs := StringMap.empty ; 
                    lfuns := StringMap.empty; 
                    preds := StringMap.empty|}
        .

    Definition translate_program (p: fsl_pgrm) : option rac_pgrm := 

        let '(decls,routines) := p in  

        (* gather all routines definitions in fenv *)
        let fenv := build_fenv routines in 

        (* perform the static analysis *)
        let t_env := Oracle.get_Γᵢ p in

        (* begin by converting c decls to gmp_decls *)
        let gmp_decls := map c_decl_to_gmp_decl decls in

        (* for each new function, reset binders  *)
        let empty_bindings := StringMap.empty in

        (* generate from left to right the globals and function definitions *)
        let res := List.fold_left (
            fun (done : @TM.t ((gmp_routine* ⨉ gmp_routine*) ⨉ ψ)%type) (doing:fsl_routine)  => 
                (* get the generated functions, translated functions and last ψ computed so far *)
                done_res <- done ;;

                let '(gen_f,tr_f, env) := done_res in 

                match doing with 
                | PFun rtype name args decls body =>
                    (* arguments and declarations are untouched *)
                    let args := map c_decl_to_gmp_decl args in 
                    let decls := map c_decl_to_gmp_decl decls in 

                    (* translate the body of the function, passing to it the last ψ *)
                    body_tr <- translate_statement fenv empty_bindings t_env env body ;;; 
                    
                    let tr_res := mkTR gmp_routine 
                        (PFun (c_t_to_gmp_t rtype) name args decls body_tr.(chunk))  
                        body_tr.(tenv) 
                        body_tr.(glob) in

                    (* append to the end of the other functions the newly translated one *)
                    let tr_f := tr_f++[tr_res.(chunk)] in  
                    
                    (* append the newly generated functions associated to the end of the others *)
                    let gen_f := gen_f++tr_res.(glob) in

                    (gen_f,tr_f, tr_res.(tenv))

                | _ => 
                    (* entry point is c functions only *)
                    TM.ret done_res
                end
                
        ) routines (TM.ret ([], [], GlobalDef.empty))
        in
        option_map (fun res =>
            let '(gen_f,tr_f) := fst  res (* discard generation_env *) in 
            (gmp_decls,gen_f++tr_f) (* first the generated functions and then the translated ones *)
        ) (TM.exec res) 
    .
End Translation.