From Coq Require Import Lists.List ZArith.ZArith Wellfounded.Lexicographic_Product.
From Coq.Strings Require Import String BinaryString.
From MMaps Require Import MMaps.
From RAC Require Import Utils Environnement Macros Oracle.
From RAC.Languages Require Import Syntax Semantics.

Import ListNotations.
Import RecordSetNotations.


Module TM := TranslationMonadNoError. 
Module TMNotations := MonadNotations(TM).
Module TMOps := MonadOps(TM).
Import TMNotations.

#[local] Open Scope string_scope.
#[local] Open Scope mini_c_scope.
#[local] Open Scope list_scope.
#[local] Open Scope Z_scope.
#[local] Open Scope mini_gmp_scope.
#[local] Open Scope utils_scope.


Definition var_list := (ùì• ‚®â gmp_t)‚òÖ.

(* helper functions *)
Definition DECLS (vars:var_list) : list gmp_decl := (* generates declarations *)
    List.fold_right (
        fun (v:ùì• ‚®â _) decls  => 
            let (s,t) := v in 
            (C_Decl t s) :: decls
    ) [] vars .

Definition INITS (vars : var_list) : gmp_statement := (* generates initialization *)
    List.fold_right 
    (
        fun (v:ùì• ‚®â _) a => let (z,t) := v in 
        match t with
        | C_Int => a
        | T_Ext Mpz => 
            let init : gmp_statement  := <( init(z) )> in 
            <{init ; a}>  
        | _ => Skip (* cannot happen  *)
        end      
    ) Skip vars.

Definition CLEARS (vars : var_list) : gmp_statement := (* generates deallocation *)
List.fold_right 
(
    fun (v:ùì• ‚®â _) a => let (z,t) := v in 
    match t with
    | T_Ext Mpz =>
        let cl : gmp_statement := <( cl(z) )> in 
        <{cl  ; a }>
    | C_Int | _  => a
    end        
) Skip vars.



Module Translation (Oracle : Oracle).

    Import Oracle.


    (* Hypothesis WellFormedProgram : well_formed_pgrm. *)


    Definition Œì·µ• := StringMap.t (ùì• ‚®â interval). (* environment for logic bindings : variable and interval infered from it *)


    Definition Œì := Œì·µ• ‚®â Œì·µ¢.
    Notation "'Œì' '(' x ')' " := (Œì·µ• x, Œì·µ¢ x).

    Module ùêº_as_OT <: OrderedType := PairOrderedType(Z_as_OT)(Z_as_OT).  

    (* maps of ordered maps over ordered type are ordered *)
    Module TypingEnv_as_OT <: OrderedType := StringMap.Decidable(ùêº_as_OT).
    (* we get an ordered type for the product of ùîè and  StringMap.t *)
    Module String_TypingEnv_as_OT <: OrderedType := PairOrderedType(String_as_OT)(TypingEnv_as_OT).
    (* finally, we get our environnement of global definitions *)
    Module GlobalDef := MMapsEnv(String_TypingEnv_as_OT).

    Definition œà : Type :=  GlobalDef.t ùì•.  (* œà(id,tenv) returns the name of the specialized version of [id] for [tenv] *)

    Definition nat_lexico := slexprod nat nat Nat.lt Nat.lt.


    Record translation_result {T : Type} := mkTR
    {
        chunk: T ;  (* code chunk  resulting of the translation *)
        tenv: œà; (* global definitions i.e. routines generated by the translation *)
        glob:gmp_routine‚òÖ; (* mini-c globals generated during translation (global var + routine) *)
    }.
    #[export] Instance etaTR {T : Type}: Settable _ := settable! (mkTR T) <chunk;tenv;glob>.


    Record translated_statement {T: Type} := mkSTR
    {
        tr : @translation_result T;

        (* fresh variables generated by the translation *)
        decls: var_list ;

        (* variable containing the result *)
        (* can't just be the varname because CMP expects an expression as 2nd and 3rd param 
            so we need both the id and type.
            Even though we only use C_Int most of the time, the oracle outputs gmp_t so it must be gmp_t
        *)
        res: ùì•  ‚®â gmp_t;
    }.
    #[export] Instance etaSTR {T : Type}: Settable _ := settable! (mkSTR T) <tr;decls;res>.

    Definition fresh_variable :=  c <- TM.fresh ;;; ("_v" ++ string_of_nat c)%string. 

    Definition fresh_fname id :=  c <- TM.fresh ;;; ("_id" ++ id ++ string_of_nat c)%string. 



    Section MutRec.
        Set Equations Transparent.
        Set Universe Polymorphism.
        Import Nat.


        Inductive logic_tr_proto : forall (A B C D : Type), (A -> B -> C -> D -> Type) -> Set :=
        | tr_pred : logic_tr_proto fsl_prog_fenv Œì œà predicate (fun _ _ _ _ => @TM.t (@translated_statement gmp_statement))
        | tr_term : logic_tr_proto fsl_prog_fenv Œì œà fsl_term (fun _ _ _ _ => @TM.t (@translated_statement gmp_statement))
        | f_gen : logic_tr_proto fsl_prog_fenv Œì œà id (fun _ _ _ _ =>  @TM.t (@translation_result ùì•))
        .

        Equations Derive Signature NoConfusion for logic_tr_proto.

        Import Sigma_Notations.


        Definition args_size {A : Type} (size:A -> nat) (l:list A) := (fold_right (fun a s => size a + s) 0 l)%nat.

        Definition args_size_lt_in : forall (A:Type) (l:list A) (f : A -> nat) (a:A), 
            List.In a l -> (f a < S (args_size f l))%nat.
        Proof. Open Scope nat.
            intros A l f a Hin. unfold args_size. induction l.
            - inversion Hin.
            - simpl in *. destruct Hin.
                *  subst. now auto with arith.
                *  apply IHl in H. clear IHl. simpl. rewrite Nat.add_comm.  auto with arith.
        Qed. 

        Fixpoint term_size (t : fsl_term) : nat :=
            match t with
            | T_Z _ | T_Id _ _  => 1
            | T_BinOp l _ r => S (term_size l) + (term_size r)
            | T_Cond p t e => S (term_size t) + (term_size e) + (pred_size p)
            | T_Call _ args => S (args_size term_size args)
        end
        with pred_size (p : predicate) :=  match p with
            | P_True | P_False => 1
            | P_Not x => S (pred_size x)
            | P_BinOp l _ r  => S (term_size l) + (term_size r)
            | P_Disj l r => S (pred_size l) + (pred_size r)
            | P_Call _ args =>  S (args_size term_size args)
        end.


        (* todo: upper bound of œà is the number of logic functions times the number of environnment for bindings *)
        Definition Œ®_max (fenv: fsl_prog_fenv) (g:Œì·µ¢) :=  
            (Nat.mul (StringMap.cardinal fenv.(lfuns)) (StringMap.cardinal g)).




        Equations measure : (Œ£ A B C D P (_ : A) (_ : B) (_ : C) (_ : D), logic_tr_proto A B C D P) -> nat ‚®â nat :=
            | (_,_,_,_,_, f_env,_,g,p,tr_pred) =>  pair 1 (pred_size p)
            | (_,_,_,_,_, f_env,_,g,t,tr_term) => pair 1 (term_size t)
            | (_,_,_,_,_, f_env,_,g,fname,f_gen)  =>  pair (GlobalDef.cardinal g) 0
        .


        Definition rel := Program.Wf.MR nat_lexico measure.
        #[global] Instance: WellFounded rel.
        Proof.
            red. apply Wf.measure_wf. apply wf_slexprod; apply Wf_nat.lt_wf. 
        Defined.


        (* pack take the function and all its arguments *)
        Definition pack {A B C D} {P} (x1 : A) (x2 : B) (x3 : C) (x4 : D) (t : logic_tr_proto A B C D P) :=
            (A,B,C,D,P, x1, x2, x3, x4, t) : (Œ£ A B C D P (_ : A) (_ : B) (_ : C) (_ : D), logic_tr_proto A B C D P).

    End MutRec.

    #[local] Notation "x 'ins:' p" := (exist _ x p) (only parsing, at level 20).

    #[local] Axiom fixme : forall (last_env:œà),  (Nat.lt (GlobalDef.cardinal last_env) 1 /\ Nat.lt 1 (GlobalDef.cardinal last_env)).

    #[local] Axiom fixme2: forall n (f: fsl_prog_fenv),
        StringMap.find n (preds f) <> None 
        /\
        StringMap.find n (funs f) <> None
        /\
        StringMap.find n (lfuns f) <> None
        /\
        StringMap.find n (procs f) <> None
    .

    #[local] Axiom fixme3: forall v (g:Œì), StringMap.find v (fst g) <> None /\ StringMap.find v (snd g) <> None.


    Local Obligation Tactic := 
    simpl in *; Tactics.program_simplify; CoreTactics.equations_simpl; try Tactics.program_solve_wf ;
    red ;red ; cbn ;  try (constructor 2; auto with arith); try now apply args_size_lt_in.
    
    Equations? translate_fsl {A B C D} {P} (t : logic_tr_proto A B C D P) (f : A) (g:B) (e: C) (x : D)  
        : P f g e x by wf (pack f g e x t) rel  := 

    (* predicate translation *)

    | tr_pred , _, _  , _ , P_True => 
            c <- fresh_variable ;;
            let decl := [(c,C_Int)] in
            let code := <{ (Assign c 1) }> in
            TM.ret (mkSTR gmp_statement (mkTR gmp_statement code e nil) decl (c,C_Int))

    | tr_pred , _, _  , _ , P_False => 
            c <- fresh_variable ;; 
            let decl := [(c,C_Int)] in
            let code := <{ (Assign c 0) }> in
            TM.ret (mkSTR gmp_statement (mkTR gmp_statement code e nil) decl  (c, C_Int))

    | tr_pred , _, _  , _ , P_Not p =>             
            c <- fresh_variable ;; 
            p_tr <- translate_fsl tr_pred f g e p ;;;
            let _res := C_Id (fst p_tr.(res)) (snd p_tr.(res)) in
            let decl := (c,C_Int)::p_tr.(decls) in
            let code := <{ (p_tr.(tr).(chunk gmp_statement)) ; if _res (Assign c 0) else (Assign c 1) }> in
            mkSTR gmp_statement (mkTR gmp_statement code p_tr.(tr).(tenv gmp_statement) nil) decl (c, C_Int)
        
    | tr_pred , _, _  , _ , P_Disj p1 p2 => 
            c <- fresh_variable ;;
            tr_p1 <- translate_fsl tr_pred f g e p1 ;;
            let p1_res := C_Id (fst tr_p1.(res)) (snd tr_p1.(res)) in
            let p1_code := tr_p1.(tr).(chunk gmp_statement) in
            tr_p2 <- translate_fsl tr_pred f g tr_p1.(tr).(tenv gmp_statement) p2 ;;;
            let p2_res := C_Id (fst tr_p2.(res)) (snd tr_p2.(res)) in
            let p2_code := tr_p2.(tr).(chunk gmp_statement) in
            let decl := (c,C_Int)::tr_p1.(decls) ++ tr_p2.(decls) in
            let code := <{ p1_code ; if p1_res (Assign c 1) else <{ p2_code ; <{(Assign c p2_res)}> }> }> 
            in
            mkSTR gmp_statement (mkTR gmp_statement code tr_p2.(tr).(tenv gmp_statement) nil) decl  (c,C_Int)

    | tr_pred , _, _ , _ , P_BinOp t1 fsl_op t2 =>            
            c <- fresh_variable ;;
            tr_t1 <- translate_fsl tr_term f g e t1 ;;
            let t1_code := tr_t1.(tr).(chunk gmp_statement) in
            tr_t2 <- translate_fsl tr_term f g tr_t1.(tr).(tenv gmp_statement) t2 ;;
            let t2_code := tr_t2.(tr).(chunk gmp_statement) in

            let decl := ("v1", T_Ext Mpz)::("v2",T_Ext Mpz)::(c,C_Int)::tr_t1.(decls) ++ tr_t2.(decls) in

            let (ct1,tt1) := tr_t1.(res) in 
            let (ct2,tt2) := tr_t1.(res) in 
            let comp := CMP c (C_Id ct1 tt1) (C_Id ct2 tt2) "v1" "v2" in 

            let code := <{ t1_code ; t2_code; comp ; (Assign c (BinOpBool (C_Id c C_Int) (‚óñfsl_op) 0)) }>  in
            TM.ret (mkSTR gmp_statement (mkTR gmp_statement code tr_t2.(tr).(tenv gmp_statement) []) decl  (c,C_Int))

    | tr_pred , _, _ , _ , P_Call pname args  =>  
        match Logic.inspect (StringMap.find pname f.(preds)) with
        | None ins:_ =>  False_rect _ _

        | Some (params,_) ins:HInpreds  => 

            (* value returned by the function call *)
            c <- fresh_variable ;;

            (* for each pair of function argument and parameter *)
            f_res <- fold_left2_in args params ( fun 
                (done: @TM.t (var_list ‚®â list c_exp ‚®â translation_result ‚®â StringMap.t (id ‚®â interval))) 
                (arg : {x | In x args})
                (param : {x : ùîè | In x params}) => 

                let HInpreds := HInpreds in

                done <- done ;;


                (* 
                    for some reason, equations fails to prove functional induction if using let patterns 
                    (even with annotation).

                    it also required to add explicit types to the function parameters of fold_left2_in as well as  
                    trading the `with clause` for the regular match. The `let HInpreds := HInpreds in` 
                    propagates the knowledege that `pname` is in `f.(preds)`

                let '(curr_decls,curr_args_ids,curr_tr,binds)  := done  in   *)


                (* get current declarations, translation and bindings environment *)
                let curr_decls := fst (fst (fst (done))) in
                let curr_args_ids := snd (fst (fst done)) in
                let curr_tr := snd (fst done) in
                let binds := snd done in


                (* translate the argument *)
                t_tr <- translate_fsl tr_term f g curr_tr.(tenv) (proj1_sig arg) ;;

                let new_tr := curr_tr 
                    <| tenv := t_tr.(tr).(tenv) |> (* pass the updated env *)
                    <| chunk ::= fun s => Seq s t_tr.(tr).(chunk) |> (* append the code generated by the translation of t*)
                    <| glob ::= fun globs => app globs t_tr.(tr).(glob) |> (* append the new globals *)
                in 

                (* building the fresh binding env for parameters *)
                v <- fresh_variable ;;;
                let interval := oracle (proj1_sig arg,snd g) in

                (* collect and append  *)
                ( 
                    curr_decls ++ t_tr.(decls), (* the new fresh variables from the translation of the argument *)
                    curr_args_ids ++ [C_Id (fst t_tr.(res)) (snd t_tr.(res))], (* the variable used to represent the argument *)
                    new_tr, (* the updated function translation  *)
                    StringMap.add (proj1_sig param) (v,interval) binds (* the updated bindings *)
                ) 

            ) (TM.ret ([(c,C_Int)], ([] : list c_exp), mkTR gmp_statement Skip e [], StringMap.empty)) 
            
            ;;

            let '(decls,params_id,f_tr,binds) := f_res in 
            
            (* last env needed for function generation *)
            let last_env := f_tr.(tenv) in 

            (* get specialized function name, env and globals  *)
            gf <- match GlobalDef.find (pname,(snd g)) e with
            (* function already exists for current binders, no generation required, 
                env is the same as the current one 
                no new globals 
            *)
            | Some name => TM.ret (name,e,[]) 
            | None => (* no function specialized for those binders, generate a new one *)
                new_f <- translate_fsl f_gen f (binds,(snd g)) last_env pname ;;;
                (* one new global : the function declaration itself *)
                (new_f.(chunk), new_f.(tenv), new_f.(glob))
            end ;;;

            let '(gf_name,gf_env,gf_globs) := gf in  
            
            (* append function globals to the globals *)
            let globs := f_tr.(glob) ++ gf_globs in

            (* return value *)
            let res := (c,C_Int) (* c is int because return value is either 0 or 1 *) in 

            (* create calling code *)
            let code := PCall gf_name params_id in

            mkSTR gmp_statement (mkTR _ code gf_env globs) decls res
        end
        

    (* term translation *)

    | tr_term , _, _ , _ , T_Id v FSL_Int => 
         (* program variable *)
        TM.ret (mkSTR gmp_statement (mkTR gmp_statement Skip e nil) nil (v,C_Int))

    | tr_term , _, _ , _ , T_Id v FSL_Integer with Logic.inspect (StringMap.find v (fst g)) => (* logic var *)
        {
            | Some (x,i) ins: HInG => 
                TM.ret (mkSTR gmp_statement (mkTR gmp_statement Skip e nil) nil (x,ty_from_interval i))
            | None ins:_ => False_rect _ _
        } 

    | tr_term , _, _ , _ , T_Z z =>
            let œÑ := get_ty (T_Z z,snd g) in
            c <- fresh_variable ;;
            let decl := [(c,œÑ)]  in 
            let code := Z_ASSGN œÑ c z in
            TM.ret (mkSTR gmp_statement (mkTR gmp_statement code e nil) decl (c,œÑ))

    | tr_term , _, _ , _ , T_BinOp t1 _op t2 =>
            let œÑ := get_ty (T_BinOp t1 _op t2,snd g) in
            c <- fresh_variable ;;
            v1 <- fresh_variable ;;
            v2 <- fresh_variable ;;
            r <- fresh_variable ;;
            t1_tr <- translate_fsl tr_term f g e t1  ;; 
            let t1_code := t1_tr.(tr).(chunk gmp_statement) in
            let t1_res := C_Id (fst t1_tr.(res)) (snd t1_tr.(res)) in
            t2_tr <- translate_fsl tr_term f g t1_tr.(tr).(tenv gmp_statement) t2  ;; 
            let t2_code := t2_tr.(tr).(chunk gmp_statement) in
            let t2_res :=  C_Id (fst t2_tr.(res)) (snd t2_tr.(res)) in
            let decl := (c,œÑ) :: (v1,T_Ext Mpz) :: (v2,T_Ext Mpz) :: (r,T_Ext Mpz) :: t1_tr.(decls) ++ t2_tr.(decls) in
            let assgn := binop_ASSGN _op (c,œÑ) t1_res t2_res r v1 v2 in
            let code := <{ t1_code ; t2_code ; assgn }> in
            TM.ret (mkSTR gmp_statement (mkTR gmp_statement code t2_tr.(tr).(tenv gmp_statement) nil) decl (c,C_Int))

    | tr_term , _, _ , _ ,T_Cond p t1 t2 =>
            c <- fresh_variable ;;
            let œÑ := get_ty  (T_Cond p t1 t2,snd g) in
            p_tr <- translate_fsl tr_pred f g e p ;;
            t1_tr <- translate_fsl tr_term f g p_tr.(tr).(tenv gmp_statement) t1  ;; 
            let t1_code := t1_tr.(tr).(chunk gmp_statement) in
            let t1_res := C_Id (fst t1_tr.(res)) (snd t1_tr.(res))  in
            t2_tr <- translate_fsl tr_term f g t1_tr.(tr).(tenv gmp_statement) t2  ;;;
            let t2_code := t2_tr.(tr).(chunk gmp_statement) in
            let t2_res := C_Id (fst t2_tr.(res)) (snd t2_tr.(res)) in
            let p_code  := p_tr.(tr).(chunk gmp_statement) in 
            let p_res := C_Id (fst p_tr.(res)) (snd p_tr.(res)) in
            let t1_assgn := œÑ_ASSGN œÑ c t1_res in
            let t2_assgn := œÑ_ASSGN œÑ c t2_res in
            let decl := (c,œÑ) :: p_tr.(decls) ++ t1_tr.(decls) ++ t2_tr.(decls) in
            let code := 
                <{
                    p_code;
                    if (p_res) <{ t1_code ; t1_assgn}> 
                    else <{t2_code ; t2_assgn }>
                }> in
            mkSTR gmp_statement (mkTR gmp_statement code t2_tr.(tr).(tenv gmp_statement) nil) decl  (c,C_Int)

    | tr_term , _, _ , _ , T_Call fname args with Logic.inspect (StringMap.find fname f.(lfuns)) =>  
        {
            | None ins:_ => False_rect _ _

            | Some (params,_) ins:HInlfuns =>

                let rtype :=  get_ty (T_Call fname args,snd g) in 
                
                (* value returned by the function call *)
                c <- fresh_variable ;;

                (* for each pair of function argument and parameter *)
                f_res <- fold_left2_in args params ( fun 
                    (done: @TM.t (var_list ‚®â list c_exp ‚®â translation_result ‚®â StringMap.t (id ‚®â interval))) 
                    (arg : {x | In x args})
                    (param : {x : ùîè | In x params}) => 

                    done <- done ;;



                    (* get current declarations, translation and bindings environment *)
                    let '(curr_decls,curr_args_ids,curr_tr, binds) := done : (_ ‚®â _ ‚®â _) in 
                    (* let curr_decls := fst (fst (fst (done))) in
                    let curr_args_ids := snd (fst (fst done)) in
                    let curr_tr := snd (fst done) in
                    let binds := snd done in *)


                    (* translate the argument *)
                    t_tr <- translate_fsl tr_term f g curr_tr.(tenv) (proj1_sig arg) ;;

                    let new_tr := curr_tr 
                        <| tenv := t_tr.(tr).(tenv) |> (* pass the updated env *)
                        <| chunk ::= fun s => Seq s t_tr.(tr).(chunk) |> (* append the code generated by the translation of t*)
                        <| glob ::= fun globs => app globs t_tr.(tr).(glob) |> (* append the new globals *)
                    in 

                    (* building the fresh binding env for parameters *)
                    v <- fresh_variable ;;;
                    let interval := oracle (proj1_sig arg,snd g)  in

                    (* collect and append  *)
                    ( 
                        curr_decls ++ t_tr.(decls), (* the new fresh variables from the translation of the argument *)
                        curr_args_ids ++ [C_Id (fst t_tr.(res)) (snd t_tr.(res))], (* the variable used to represent the argument *)
                        new_tr, (* the updated function translation  *)
                        StringMap.add (proj1_sig param) (v,interval) binds (* the updated bindings *)
                    )

                ) (TM.ret ([(c,rtype)], ([] : list c_exp), mkTR gmp_statement Skip e [], StringMap.empty)) 

                ;;

                let '(decls,params_id,f_tr,binds) := f_res in 
                
                (* last env needed for function generation *)
                let last_env := f_tr.(tenv) in 

                (* get specialized function name, env and globals  *)
                gf <- match GlobalDef.find (fname,(snd g)) e with
                (* function already exists for current binders, no generation required, 
                    env is the same as the current one 
                    no new globals 
                *)
                | Some name => TM.ret (name,e,[]) 
                | None => (* no function specialized for those binders, generate a new one *)
                    new_f <- translate_fsl f_gen f (binds,(snd g)) last_env fname ;;;
                    (* one new global : the function declaration itself *)
                    (new_f.(chunk), new_f.(tenv), new_f.(glob))
                end ;;

                let '(gf_name,gf_env,gf_globs) := gf in  
                
                (* append function globals to the globals *)
                let globs := f_tr.(glob) ++ gf_globs in

                (* return value *)
                let res := (c,C_Int) (*fixme : what type is c ? *) in 

                (* create calling code *)
                code <- match Logic.inspect rtype  with
                    | C_Int ins:_ => TM.ret (FCall c gf_name params_id)
                    | T_Ext (Mpz) ins:_ => 
                        let firstparam := C_Id (fst res) (snd res) in 
                        TM.ret (PCall gf_name (firstparam :: params_id))
                    | _ ins:Hty => let _ := Hty in False_rect _ _
                end ;;;
                
                mkSTR gmp_statement (mkTR _ code gf_env globs) decls res
        }


    (* function generation *)
                
    | f_gen, _,_,_,fname with Logic.inspect (StringMap.find fname f.(lfuns)) =>
        {
            | None ins:_ =>  False_rect _ _
            | Some (params,b) ins:HInlfuns => 
                (* get the return type *)
                let rtype := get_ty (b,snd g) in

                (* generate a fresh name for the new function *)
                fres <- fresh_fname fname;;

                (* process body *)

                tr_b <- translate_fsl tr_term f g e b ;;

                (* global declarations generated by the body , appended before function declaration  *)
                let globals := tr_b.(tr).(glob) in

                (* prepare env update : 
                    indexed by the original name of the function and what binders interval Œì·µ¢ it is for ;
                    returns the unique generated function id for those binders
                *)
                let upd_binding := GlobalDef.add (fname,(snd g)) fres in

                let new_env := upd_binding tr_b.(tr).(tenv) in        

                (* in case the result is too big to fit in a machine integer *)
                let retvar := "_ret" in

                 (*  build the signature of the function *)
                signature <- (
                    (* figure out the type and id of parameters *)
                    params <- TMOps.map (fun p => 
                        i <- match Logic.inspect (StringMap.find p (snd g)) with
                            | Some i ins:_ => TM.ret i 
                            | None ins:Hty => let _ := Hty in False_rect _ _
                            end ;;
                        (* get the corresponding id *)
                        v <- match Logic.inspect (StringMap.find p (fst g)) with 
                            | Some (v,_) ins:_ => TM.ret v  
                            | None ins:Hty => let _ := Hty in False_rect _ _
                            end 
                        ;;;
                        C_Decl (ty_from_interval i) v
                    ) params ;; 

                    match Logic.inspect rtype with
                    | C_Int ins:_ => 
                        TM.ret (PFun C_Int fres params)
                    | T_Ext Mpz ins:_ => 
                        (* if rtype is mpz, pass function result using first argument *)
                        TM.ret (PFun Void fres ((C_Decl (T_Ext Mpz) retvar)::params))
                    | _ ins:Hty => let _ := Hty in False_rect _ _
                    end 
                ) ;;
                
                (* build the body *)
                (* reprocess body with original œà + new f entry *)
                tr_b <- translate_fsl tr_term f g (upd_binding e) b;;;

                let '(body_res_id,body_res_ty) as bres := tr_b.(res) in 
                (* body epilogue *)
                let bdecls := DECLS [bres] in
                let inits := INITS [bres] in 

                let code := tr_b.(tr).(chunk) in
                
                let rv := (C_Id body_res_id body_res_ty) in
                let cl := CLEARS [bres] in
                (* body prologue *)
                let ret_and_cleanup := match rtype with
                | C_Int =>  <{ cl ; return rv}>
                | T_Ext Mpz => 
                    let setret : gmp_statement := Set_z retvar body_res_id
                    in <{ setret ;  cl }>
                | _ => Skip end 
                in
                let body := <{ inits ; code ; ret_and_cleanup }> in 
                let gen_f := signature bdecls body in
                mkTR _ fres new_env (globals++[gen_f]) (* function declarations is put with the other globals *)
        }   
    .
    
    - constructor. apply fixme.
    - now apply fixme2 in e1.
    - now apply  fixme3 in e0.
    - constructor. apply fixme.
    - destruct get_ty eqn:Hget; try discriminate.  unfold get_ty in Hget. 
        pose proof (œ¥_int_or_mpz (oracle (T_Call fname args,snd g))) as [H|H]; now rewrite Hget in H.
    - destruct get_ty eqn:Hget; try discriminate. destruct t; try discriminate.
        pose proof (œ¥_int_or_mpz (oracle (T_Call fname args,snd g))) as [H|H]; subst;  unfold get_ty in Hget; congruence.
    - now apply fixme2 in e0.
    - constructor. apply fixme.
    - now apply fixme3 in e0.
    - now apply fixme3 in e0.
    - destruct get_ty eqn:Hget; try discriminate. unfold get_ty in Hget. 
        pose proof (œ¥_int_or_mpz (oracle (b,snd g))) as [H|H]; congruence.
    - destruct get_ty eqn:Hget; try discriminate. destruct t; try discriminate.
        pose proof (œ¥_int_or_mpz (oracle (b,snd g))) as [H|H]; subst;  unfold get_ty in Hget; congruence.
    - constructor. apply fixme.
    - now apply  fixme2 in e0.
    Qed.

    (* Solve Obligations with 
        unshelve (simpl in *; Tactics.program_simplify; CoreTactics.equations_simpl; try Tactics.program_solve_wf; 
        red ;red ; cbn ;  try (constructor 2; auto with arith); try now apply args_size_lt_in. *)


    Definition translate_term := translate_fsl tr_term.
    Definition translate_pred := translate_fsl tr_pred.
    Definition generate_function := translate_fsl f_gen.


    (* translation of statements *)
    Equations translate_statement (f:fsl_prog_fenv) (g:Œì) (env: œà) (s : fsl_statement) : @TM.t (@translation_result gmp_statement) := 
    | _,_,_, S_Ext (LAssert p)  =>
        p_tr <- translate_fsl tr_pred f g env p;;;
        let d := DECLS p_tr.(decls) in
        let i := INITS p_tr.(decls) in
        let c := p_tr.(tr).(chunk gmp_statement) in
        let res := C_Id (fst p_tr.(res)) (snd p_tr.(res)) in
        let asrt := PAssert res in
        let clr := CLEARS p_tr.(decls) in 
        p_tr.(tr) 
            <| chunk := (Scope d <{i ;c ; asrt ; clr }> : gmp_statement) |> 
            (* Before, we propagated declarations global declarations
                because the syntax forbids declarations to be put in a statement.
                It was a hack that required a different treatement inside translate_program might not have been correct.
                Now, with Scope added to the c syntax, this is not necessary.

                <| glob ::= fun l => l ++ (map GDecl d) |>
            *)            
        
    | _,_,_, FCall x name args => 
        let args := map c_exp_to_gmp_exp args in 
        TM.ret (mkTR gmp_statement (FCall x name args) env nil)


    | _,_,_, Seq s1 s2  => 
        s1_tr <- translate_statement f g env s1 ;;
        s2_tr <- translate_statement f g s1_tr.(tenv) s2 ;;;
        s2_tr <| chunk := Seq s1_tr.(chunk) s2_tr.(chunk) |> <| glob ::= app s1_tr.(glob) |>

    | _,_,_, If e s1 s2 => 
        let e := c_exp_to_gmp_exp e in 
        s1_tr <- translate_statement f g env s1 ;;
        s2_tr <- translate_statement f g s1_tr.(tenv) s2 ;;;
        s2_tr <| chunk := If e s1_tr.(chunk) s2_tr.(chunk) |> <| glob ::= app s1_tr.(glob) |>

    | _,_,_, While e b =>  
        let e := c_exp_to_gmp_exp e in 
        tr <- translate_statement f g env b ;;; 
        tr <| chunk := (While e tr.(chunk)) |>

    | _,_,_, (Assign var e) => TM.ret (mkTR gmp_statement (Assign var (c_exp_to_gmp_exp e)) env nil)

    | _,_,_, PAssert e => 
        let e := c_exp_to_gmp_exp e in 
        TM.ret (mkTR gmp_statement (PAssert e) env nil)

    | _,_,_, Return e => 
        let e := c_exp_to_gmp_exp e in 
        TM.ret (mkTR gmp_statement (Return e) env nil)
    | _,_,_, PCall name args => let args := map c_exp_to_gmp_exp args in TM.ret (mkTR gmp_statement (PCall name args) env nil)

    | _,_,_, Scope d s => 
        let decls := map c_decl_to_gmp_decl d in 
        tr <- translate_statement f g env s ;;;
        tr <| chunk := Scope decls tr.(chunk) |>

    | _,_,_, Skip => TM.ret (mkTR gmp_statement Skip env nil)
    .

    Equations translate_routine (fenv : fsl_prog_fenv) (t_env : Œì·µ¢) (done : (gmp_routine‚òÖ ‚®â gmp_routine‚òÖ ‚®â œà)%type) : fsl_routine -> @TM.t (gmp_routine‚òÖ ‚®â gmp_routine‚òÖ ‚®â œà) := 
    | _,_,_, PFun rtype name args pdecls body =>

        let '(gen_f,tr_f, env) := done in 

        (* for each new function, reset binders  *)
        let empty_bindings := StringMap.empty in

        (* arguments and declarations are untouched *)
        let args := map c_decl_to_gmp_decl args in 
        let pdecls := map c_decl_to_gmp_decl pdecls in 

        (* translate the body of the function, passing to it the last œà *)
        body_tr <- translate_statement fenv (empty_bindings,t_env) env body ;;; 
        
        let tr_res := mkTR gmp_routine 
            (PFun (c_t_to_gmp_t rtype) name args pdecls body_tr.(chunk))  
            body_tr.(tenv) 
            body_tr.(glob) in

        (* append to the end of the other functions the newly translated one *)
        let tr_f := tr_f++[tr_res.(chunk)] in  
        
        (* append the newly generated functions associated to the end of the others *)
        let gen_f := gen_f++tr_res.(glob) in

        (gen_f,tr_f, tr_res.(tenv))
    | _,_,_, _ => 
        (* entry point is c functions only *)
        TM.ret done
    .


    Equations translate_program : fsl_pgrm -> rac_pgrm := 
    | (decls,routines) =>

        (* gather all routines definitions in fenv *)
        let fe := build_fsl_fenv routines in 

        (* perform the static analysis *)
        let t_env := Oracle.get_Œì·µ¢ (decls,routines) in


        (* generate from left to right the globals and function definitions *)
        let res := TMOps.fold (translate_routine fe t_env) routines ([], [], GlobalDef.empty)
        in
        let '((gen_f,tr_f),_) := TM.exec res in
        (*  convert c decls to gmp_decls *)
        let gmp_decls := map c_decl_to_gmp_decl decls in
        (gmp_decls,gen_f++tr_f) (* first the generated functions and then the translated ones *)
    .


    Notation "‚ü¶ P ‚üß" := (translate_program P).
End Translation.