Require Import RAC.Definitions.
Require Import RAC.Notations.
Require Import RAC.Utils.
Require Import String.
Require Import BinaryString.
Open Scope string_scope.
Open Scope mini_c_scope.
Require Import List.
Import ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Export CounterMonad.
Require Import ZArith.ZArith.
Require Import BinaryString.
From RecordUpdate Require Import RecordUpdate.
Import RecordSetNotations.

Open Scope mini_gmp_scope.


(* macro definitions *)


Definition mpz_ASSGN v (e: gmp_exp ) : gmp_statement := match ty e with
    | T_Ext Mpz => match e with
                    | C_Id x _ => <( set_z(v,x) )>
                    | _ => Skip (* cannot happen *)
                    end
    | C_Int => <( set_i(v,e) )> : gmp_statement
    | _ => Skip (* cannot happen  *)
end.

Definition int_ASSGN v (e: gmp_exp) : gmp_statement := match ty e with
    | T_Ext Mpz => match e with
                    | C_Id x _ => <( v = get_int(x) )>
                    | _ => Skip (* cannot happen *)
                    end
    
    | C_Int =>  <{ v = e }>
    | _ => Skip
end.

Definition œÑ_ASSGN (t:gmp_t) := match t with
    | T_Ext Mpz => mpz_ASSGN
    | C_Int => int_ASSGN
    | _ => int_ASSGN (* cannot happen  *)
    end.

Definition Z_ASSGN (œÑz:gmp_t) v (z:Z) : gmp_statement := match œÑz with
    | C_Int => <{ v = z }>
    | T_Ext Mpz => <( set_s(v, (BinaryString.of_Z z) ) )>
    | _ => Skip (* cannot happen  *)
end.




Definition CMP c (e‚ÇÅ e‚ÇÇ : gmp_exp) v‚ÇÅ v‚ÇÇ : gmp_statement := match ty e‚ÇÅ, ty e‚ÇÇ with
    |  C_Int,C_Int => 
        <{ 
            if (e‚ÇÅ < e‚ÇÇ) c = 0-1
            else if (e‚ÇÅ > e‚ÇÇ) c = 1
            else c = 0
        }>
    | _,_ => 
        let a1 := mpz_ASSGN v‚ÇÅ e‚ÇÅ in 
        let a2 := mpz_ASSGN v‚ÇÇ e‚ÇÇ in
        let cmp : gmp_statement := <( c = cmp(v‚ÇÅ,v‚ÇÇ) )> in
        <{ a1 ; a2 ; cmp }>
end
.


Definition binop_ASSGN (fsl_op:fsl_binop_int) (v:ùì• ‚®â gmp_t) e‚ÇÅ e‚ÇÇ (r:id) v‚ÇÅ v‚ÇÇ : gmp_statement := 
    let (c,œÑ) := v in
    match œÑ,(ty e‚ÇÅ),(ty e‚ÇÇ) with
    | C_Int,C_Int,C_Int =>  let res := BinOpInt e‚ÇÅ (‚ñ° fsl_op) e‚ÇÇ in <{ c = res }>
    | _,_,_ => 
        let s1 :=  mpz_ASSGN v‚ÇÅ e‚ÇÅ in
        let s2 :=  mpz_ASSGN v‚ÇÇ e‚ÇÇ in
        let s3 : gmp_statement := match œÑ with
            | C_Int => 
                let op : gmp_statement  := <( (op fsl_op r v‚ÇÅ v‚ÇÇ) )> in
                let r : gmp_exp := (C_Id r (T_Ext Mpz)) in 
                <{op  ; <( (int_ASSGN c r) )> }>                    
            | T_Ext Mpz => op fsl_op c v‚ÇÅ v‚ÇÇ
            | _ => Skip
            end
        in <{s1;s2;s3}>

    end
    .


Definition var_list := (ùì• ‚®â gmp_t) ‚É∞.

(* helper functions *)
Definition DECLS (vars:var_list) : list gmp_decl := (* generates declarations *)
    List.fold_right (
        fun (v:ùì• ‚®â _) decls  => 
            let (s,t) := v in 
            (C_Decl t s) :: decls
    ) [] vars .

Definition INITS (vars : var_list) : gmp_statement := (* generates initialization *)
    List.fold_right 
    (
        fun (v:ùì• ‚®â _) a => let (z,t) := v in 
        match t with
        | C_Int => a
        | T_Ext Mpz => 
            let init : gmp_statement  := <( init(z) )> in 
            <{init ; a}>  
        | _ => Skip (* cannot happen  *)
        end      
    ) Skip vars.

Definition CLEARS (vars : var_list) : gmp_statement := (* generates deallocation *)
List.fold_right 
(
    fun (v:ùì• ‚®â _) a => let (z,t) := v in 
    match t with
    | T_Ext Mpz =>
        let cl : gmp_statement := <( cl(z) )> in 
        <{cl  ; a }>
    | C_Int | _  => a
    end        
) Skip vars.


Inductive global := GDecl (decl:gmp_decl) | GFun (f:gmp_routine).


Record translation_result {T : Type} := mkTR
{
    chunk: T ;  (* code chunk  resulting of the translation *)
    tenv: œà; (* global definitions i.e. routines generated by the translation *)
    glob:global ‚É∞ ; (* mini-c globals generated during translation (global var + routine) *)
}.
#[export] Instance etaTR {T : Type}: Settable _ := settable! (mkTR T) <chunk;tenv;glob>.


Record translated_statement {T: Type} := mkSTR
{
    tr : @translation_result T;

    (* fresh variables generated by the translation *)
    decls: var_list ;

    (* variable containing the result *)
    (* can't just be the varname because CMP expects an expression as 2nd and 3rd param 
        so we need both the id and type.
        Even though we only use C_Int most of the time, the oracle outputs gmp_t so it must be gmp_t
    *)
    res: ùì• * gmp_t;
}.
#[export] Instance etaSTR {T : Type}: Settable _ := settable! (mkSTR T) <tr;decls;res>.


Definition fresh_variable :=  c <- fresh ;;; ("_v" ++ string_of_nat c)%string. 

Definition fresh_fname id :=  c <- fresh ;;; ("_id" ++ id ++ string_of_nat c)%string. 


From Equations Require Import Equations.

Section todo.
Set Equations Transparent.

Set Universe Polymorphism.


Inductive logic_tr_proto : forall (A B C D E  : Type), (A -> B -> C -> D -> E -> Type) -> Set :=
| tr_pred : logic_tr_proto (@fenv _fsl_statement Empty_set) Œì·µ• type_inf œà predicate (fun _ _ _ _ _ => @state (@translated_statement gmp_statement))
| tr_term : logic_tr_proto (@fenv _fsl_statement Empty_set) Œì·µ• type_inf œà fsl_term (fun _ _ _ _ _ => @state (@translated_statement gmp_statement))
| f_gen : logic_tr_proto (@fenv _fsl_statement Empty_set) Œì·µ• type_inf œà id (fun _ _ _ _ _ =>  @state (@translation_result ùì•))
.

Derive Signature NoConfusion for logic_tr_proto.

Import Sigma_Notations.


Definition args_size {A : Type} (size:A -> nat) (l:list A) := (fold_right (fun a s => size a + s) 0 l)%nat.

Definition args_size_lt_in : forall (A:Type) (l:list A) (f : A -> nat) (a:A), 
    List.In a l -> (f a < S (args_size f l))%nat.
Proof. Open Scope nat.
    intros A l f a Hin. unfold args_size. induction l.
    - inversion Hin.
    - simpl in *. destruct Hin.
        *  subst. now auto with arith.
        *  apply IHl in H. clear IHl. simpl. rewrite Nat.add_comm.  auto with arith.
Qed. 

Fixpoint term_size (t : fsl_term) : nat :=
    match t with
    | T_Z _ | T_Id _ _  => 1
    | T_BinOp l _ r => S (term_size l) + (term_size r)
    | T_Cond p t e => S (term_size t) + (term_size e) + (pred_size p)
    | T_Call _ args => S (args_size term_size args)
end
with pred_size (p : predicate) :=  match p with
    | P_True | P_False => 1
    | P_Not x => S (pred_size x)
    | P_BinOp l _ r  => S (term_size l) + (term_size r)
    | P_Disj l r => S (pred_size l) + (pred_size r)
    | P_Call _ args =>  S (args_size term_size args)
end.


Equations measure : (Œ£ A B C D E P (_ : A) (_ : B) (_ : C) (_ : D) (_ : E), logic_tr_proto A B C D E P) -> nat :=
    | (_,_,_,_,_,_, _,_,_,_,p,tr_pred) => pred_size p
    | (_,_,_,_,_,_, _,_,_,_,t,tr_term) => term_size t
    | (_,_,_,_,_,_, fenv,_,_,e,fname,f_gen)  =>  0

.

Definition rel := Program.Wf.MR lt measure.
#[global] Instance: WellFounded rel.
Proof.
    red. apply Wf.measure_wf. apply Wf_nat.lt_wf.
Defined.


(* pack take the function and all its arguments *)
Definition pack {A B C D E} {P} (x1 : A) (x2 : B) (x3 : C) (x4 : D) (x5 : E) (t : logic_tr_proto A B C D E P) :=
     (A,B,C,D,E,P, x1, x2, x3, x4, x5, t) : (Œ£ A B C D E P (_ : A) (_ : B) (_ : C) (_ : D) (_ : E), logic_tr_proto A B C D E P).


End todo.


Equations translate_fsl {A B C D E} {P} (t : logic_tr_proto A B C D E P) (f : A) (bindings : B) (t_inf:C) (e:D) (x: E) : P f bindings t_inf e x by wf (pack f bindings t_inf e x t) rel := 

(* predicate translation *)

| tr_pred , _, _ , _ , _ , P_True => 
    c <- fresh_variable ;;
        let decl := [(c,C_Int)] in
        let code := <{ c = 1 }> in
        ret (mkSTR gmp_statement (mkTR gmp_statement code e nil) decl (c,C_Int))

| tr_pred , _, _ , _ , _ , P_False => 
    c <- fresh_variable ;; 
    let decl := [(c,C_Int)] in
    let code := <{ c = 0 }> in
    ret (mkSTR gmp_statement (mkTR gmp_statement code e nil) decl  (c, C_Int))

| tr_pred , _, _ , _ , _ , P_Not p => 
    c <- fresh_variable ;; 
    p_tr <- translate_fsl tr_pred f bindings t_inf e p ;;;
    let _res := C_Id (fst p_tr.(res)) (snd p_tr.(res)) in
    let decl := (c,C_Int)::p_tr.(decls) in
    let code := <{ (p_tr.(tr).(chunk gmp_statement)) ; if _res c = 0 else c = 1 }> in
    mkSTR gmp_statement (mkTR gmp_statement code p_tr.(tr).(tenv gmp_statement) nil) decl (c, C_Int)

| tr_pred , _, _ , _ , _ , P_Disj p1 p2 => 
    c <- fresh_variable ;;
    tr_p1 <- translate_fsl tr_pred f bindings t_inf e p1 ;;
    let p1_res := C_Id (fst tr_p1.(res)) (snd tr_p1.(res)) in
    let p1_code := tr_p1.(tr).(chunk gmp_statement) in
    tr_p2 <- translate_fsl tr_pred f bindings t_inf tr_p1.(tr).(tenv gmp_statement) p2 ;;;
    let p2_res := C_Id (fst tr_p2.(res)) (snd tr_p2.(res)) in
    let p2_code := tr_p2.(tr).(chunk gmp_statement) in
    let decl := (c,C_Int)::tr_p1.(decls) ++ tr_p2.(decls) in
    let code := <{ p1_code ; if p1_res c = 1 else <{ p2_code ; <{c = p2_res}> }> }> 
    in
    mkSTR gmp_statement (mkTR gmp_statement code tr_p2.(tr).(tenv gmp_statement) nil) decl  (c,C_Int)

| tr_pred , _, _ , _ , _ , P_BinOp t1 fsl_op t2 =>
    c <- fresh_variable ;;

    tr_t1 <- translate_fsl tr_term f bindings t_inf e t1 ;;
    let t1_code := tr_t1.(tr).(chunk gmp_statement) in
    tr_t2 <- translate_fsl tr_term f bindings t_inf tr_t1.(tr).(tenv gmp_statement) t2  ;;
    let t2_code := tr_t2.(tr).(chunk gmp_statement) in

    let decl := ("v1", T_Ext Mpz)::("v2",T_Ext Mpz)::(c,C_Int)::tr_t1.(decls) ++ tr_t2.(decls) in

    let (ct1,tt1) := tr_t1.(res) in 
    let (ct2,tt2) := tr_t1.(res) in 
    let comp := CMP c (C_Id ct1 tt1) (C_Id ct2 tt2) "v1" "v2" in 

    let code := <{ t1_code ; t2_code; comp ; (Assign c (BinOpBool (C_Id c C_Int) (‚óñfsl_op) 0)) }>  in
    ret (mkSTR gmp_statement (mkTR gmp_statement code tr_t2.(tr).(tenv gmp_statement) []) decl  (c,C_Int))

| tr_pred , _, _ , _ , _ , P_Call pname args with f.(preds) pname =>  
    {
        (* shouldn't happen *)
        | None => ret (mkSTR gmp_statement (mkTR gmp_statement Skip e nil) nil  ("",C_Int))

        | Some (params,_) => 
            (* value returned by the function call *)
            c <- fresh_variable ;;

            (* for each pair of function argument and parameter *)
            let f_res := fold_left2_in args params ( fun done arg param => 
                done <- done ;;

                (* get current declarations, translation and bindings environment *)
                let '(curr_decls,curr_args_ids,curr_tr, binds) := done : (_ * _ * _) in 
                

                (* translate the argument *)
                t_tr <- translate_fsl tr_term f bindings t_inf curr_tr.(tenv) (proj1_sig arg) ;;

                let new_tr := curr_tr 
                    <| tenv := t_tr.(tr).(tenv) |> (* pass the updated env *)
                    <| chunk ::= fun s => Seq s t_tr.(tr).(chunk) |> (* append the code generated by the translation of t*)
                    <| glob ::= fun globs => app globs t_tr.(tr).(glob) |> (* append the new globals *)
                in 

                (* building the fresh binding env for parameters *)
                v <- fresh_variable ;;;
                let interval := t_inf.(oracle) (proj1_sig arg) t_inf.(t_env)  in

                (* collect and append  *)
                ( 
                    curr_decls ++ t_tr.(decls), (* the new fresh variables from the translation of the argument *)
                    curr_args_ids ++ [C_Id (fst t_tr.(res)) (snd t_tr.(res))], (* the variable used to represent the argument *)
                    new_tr, (* the updated function translation  *)
                    binds{(proj1_sig param)\(v,interval)} (* the updated bindings *)
                )

            ) (ret ([(c,C_Int)], ([] : list _c_exp), mkTR gmp_statement Skip e [], ‚ä•))  in
        
            f_res <- f_res ;;

            let '(decls,params_id,f_tr,binds) := f_res in 
        
            (* last env needed for function generation *)
            let last_env := f_tr.(tenv) in 

            (* get specialized function name, env and globals  *)
            gf <- match e (pname,t_inf.(t_env)) with
            (* function already exists for current binders, no generation required, 
                env is the same as the current one 
                no new globals 
            *)
            | Some name => ret (name,e,[]) 
            | None => (* no function specialized for those binders, generate a new one *)
                new_f <- translate_fsl f_gen f binds t_inf last_env pname ;;;
                (* one new global : the function declaration itself *)
                (new_f.(chunk), new_f.(tenv), new_f.(glob))
            end ;;;

            let '(gf_name,gf_env,gf_globs) := gf in  
            
            (* append function globals to the globals *)
            let globs := f_tr.(glob) ++ gf_globs in

            (* return value *)
            let res := (c,C_Int) (* c is int because return value is either 0 or 1 *) in 

            (* create calling code *)
            let code := PCall gf_name params_id in

            mkSTR gmp_statement (mkTR _ code gf_env globs) decls res
    }

(* term translation *)

| tr_term , _, _ , _ , _ , T_Id v FSL_Int => 
    (* program variable *)
    ret (mkSTR gmp_statement (mkTR gmp_statement Skip e nil) nil (v,C_Int))

| tr_term , _, _ , _ , _ , T_Id v FSL_Integer => (* logic var *)
    let res := match bindings v with 
        (*  bindings v necessarily succeeds (section 4.5.)... *)
        | Some x => fst x
        | None => "fixme"
    end in 
    ret (mkSTR gmp_statement (mkTR gmp_statement Skip e nil) nil (v,T_Ext Mpz))

| tr_term , _, _ , _ , _ , T_Z z =>
    let œÑ := ùö™ t_inf.(oracle) t_inf.(i_op) z t_inf.(t_env) in
    c <- fresh_variable ;;
    let decl := [(c,œÑ)]  in 
    let code := Z_ASSGN C_Int c z in
    ret (mkSTR gmp_statement (mkTR gmp_statement code e nil) decl (c,C_Int))

| tr_term , _, _ , _ , _ , T_BinOp t1 _op t2 =>
    let œÑ := ùö™ t_inf.(oracle) t_inf.(i_op) (T_BinOp t1 _op t2) t_inf.(t_env) in
    c <- fresh_variable ;;
    v1 <- fresh_variable ;;
    v2 <- fresh_variable ;;
    r <- fresh_variable ;;
    t1_tr <- translate_fsl tr_term f bindings t_inf e t1  ;; 
    let t1_code := t1_tr.(tr).(chunk gmp_statement) in
    let t1_res := C_Id (fst t1_tr.(res)) (snd t1_tr.(res)) in
    t2_tr <- translate_fsl tr_term f bindings t_inf t1_tr.(tr).(tenv gmp_statement) t2 ;; 
    let t2_code := t2_tr.(tr).(chunk gmp_statement) in
    let t2_res :=  C_Id (fst t2_tr.(res)) (snd t2_tr.(res)) in
    let decl := (c,œÑ) :: (v1,T_Ext Mpz) :: (v2,T_Ext Mpz) :: (r,T_Ext Mpz) :: t1_tr.(decls) ++ t2_tr.(decls) in
    let assgn := binop_ASSGN _op (c,œÑ) t1_res t2_res r v1 v2 in
    let code := <{ t1_code ; t2_code ; assgn }> in
    ret (mkSTR gmp_statement (mkTR gmp_statement code t2_tr.(tr).(tenv gmp_statement) nil) decl (c,C_Int))


| tr_term , _, _ , _ , _ ,T_Cond p t1 t2 =>
    c <- fresh_variable ;;
    let œÑ := ùö™ t_inf.(oracle) t_inf.(i_op) (T_Cond p t1 t2) t_inf.(t_env) in

    p_tr <- translate_fsl tr_pred f bindings t_inf e p ;;

    t1_tr <- translate_fsl tr_term f bindings t_inf p_tr.(tr).(tenv gmp_statement) t1  ;; 
    let t1_code := t1_tr.(tr).(chunk gmp_statement) in
    let t1_res := C_Id (fst t1_tr.(res)) (snd t1_tr.(res))  in
    t2_tr <- translate_fsl tr_term f bindings t_inf t1_tr.(tr).(tenv gmp_statement) t2 ;;;
    let t2_code := t2_tr.(tr).(chunk gmp_statement) in
    let t2_res := C_Id (fst t2_tr.(res)) (snd t2_tr.(res)) in
    let p_code  := p_tr.(tr).(chunk gmp_statement) in 
    let p_res := C_Id (fst p_tr.(res)) (snd p_tr.(res)) in
    let t1_assgn := œÑ_ASSGN œÑ c t1_res in
    let t2_assgn := œÑ_ASSGN œÑ c t2_res in
    let decl := (c,œÑ) :: p_tr.(decls) ++ t1_tr.(decls) ++ t2_tr.(decls) in
    let code := 
        <{
            p_code;
            if (p_res) <{ t1_code ; t1_assgn}> 
            else <{t2_code ; t2_assgn }>
        }> in
    mkSTR gmp_statement (mkTR gmp_statement code t2_tr.(tr).(tenv gmp_statement) nil) decl  (c,C_Int)


| tr_term , _, _ , _ , _ , T_Call fname args with f.(lfuns) fname =>  
    {
        (* shouldn't happen *)
        | None =>  ret (mkSTR gmp_statement (mkTR gmp_statement Skip e nil) nil  ("",C_Int))

        | Some (params,_) =>

            let rtype :=  ùö™ t_inf.(oracle) t_inf.(i_op) (T_Call fname args) t_inf.(t_env) in 
            
            (* value returned by the function call *)
            c <- fresh_variable ;;

            (* for each pair of function argument and parameter *)
            let f_res := fold_left2_in  args params ( fun done arg param => 


                done <- done ;;

                (* get current declarations, translation and bindings environment *)
                let '(curr_decls,curr_args_ids,curr_tr, binds) := done : (_ * _ * _) in 
                

                (* translate the argument *)
                t_tr <- translate_fsl tr_term f bindings t_inf curr_tr.(tenv) (proj1_sig arg) ;;

                let new_tr := curr_tr 
                    <| tenv := t_tr.(tr).(tenv) |> (* pass the updated env *)
                    <| chunk ::= fun s => Seq s t_tr.(tr).(chunk) |> (* append the code generated by the translation of t*)
                    <| glob ::= fun globs => app globs t_tr.(tr).(glob) |> (* append the new globals *)
                in 

                (* building the fresh binding env for parameters *)
                v <- fresh_variable ;;;
                let interval := t_inf.(oracle) (proj1_sig arg) t_inf.(t_env)  in

                (* collect and append  *)
                ( 
                    curr_decls ++ t_tr.(decls), (* the new fresh variables from the translation of the argument *)
                    curr_args_ids ++ [C_Id (fst t_tr.(res)) (snd t_tr.(res))], (* the variable used to represent the argument *)
                    new_tr, (* the updated function translation  *)
                    binds{(proj1_sig param)\(v,interval)} (* the updated bindings *)
                )

            ) (ret ([(c,rtype)], ([] : list _c_exp), mkTR gmp_statement Skip e [], ‚ä•))  in

            
            f_res <- f_res ;;

            let '(decls,params_id,f_tr,binds) := f_res in 
            
            (* last env needed for function generation *)
            let last_env := f_tr.(tenv) in 

            (* get specialized function name, env and globals  *)
            gf <- match e (fname,t_inf.(t_env)) with
                (* function already exists for current binders, no generation required, 
                    env is the same as the current one 
                    no new globals 
                *)
                | Some name => ret (name,e,[]) 
                | None => (* no function specialized for those binders, generate a new one *)
                    new_f <- translate_fsl f_gen f binds t_inf last_env fname ;;;
                    (* one new global : the function declaration itself *)
                    (new_f.(chunk), new_f.(tenv), new_f.(glob))
                end ;;;

            let '(gf_name,gf_env,gf_globs) := gf in  
            
            (* append function globals to the globals *)
            let globs := f_tr.(glob) ++ gf_globs in

            (* return value *)
            let res := (c,C_Int) (*fixme : what type is c ? *) in 

            (* create calling code *)
            let code : gmp_statement := match rtype with
                | C_Int => FCall c gf_name params_id
                | T_Ext (Mpz) => 
                    let firstparam := C_Id (fst res) (snd res) in 
                    PCall gf_name (firstparam :: params_id)
                | _ => Skip (* not possible *)
            end 
            in


            mkSTR gmp_statement (mkTR _ code gf_env globs) decls res
    }

| f_gen, _,_,_,_,fname with f.(lfuns) fname =>
    {
    | Some (params,b) => 
        (* get the return type *)
        let rtype := ùö™ t_inf.(oracle) t_inf.(i_op) b t_inf.(t_env) in

        (* generate a fresh name for the new function *)
        fres <- fresh_fname fname;;

        (* process body *)
        tr_b <- translate_fsl tr_term f bindings t_inf e b ;;

        (* global declarations generated by the body , appended before function declaration  *)
        let globals := tr_b.(tr).(glob) in

        (* prepare env update : 
            indexed by the original name of the function and what binders interval Œì·µ¢ it is for ;
            returns the unique generated function id for those binders
        *)
        let upd_binding := {{(fname,(t_inf.(t_env)))\fres}} in

        let new_env := upd_binding tr_b.(tr).(tenv) in        

        (* in case the result is too big to fit in a machine integer *)
        let retvar := "_ret" in

        (*  build the signature of the function *)
        let signature : list _c_decl   -> _c_statement -> gmp_routine := 
            (* figure out the type and id of parameters *)
            let params := map (fun p => 
                let i := match t_inf.(t_env) p with
                    | Some i => i 
                    | None => mkInterval 0 0 (*fixme:  guarantee var is present in inference env  *)
                    end
                in
                (* get the corresponding id *)
                let v := match bindings p with Some (v,_) => v | None => "fixme" end in

                C_Decl (t_inf.(i_op) i) v
            ) params in 

            match rtype with
            | C_Int => PFun C_Int fres params
            (* if rtype is mpz, pass function result using first argument *)
            | T_Ext Mpz  => PFun Void fres ((C_Decl (T_Ext Mpz) retvar)::params)
            (* can't happen ... 
                thought : 
                use error monad everywhere to handle those and prove under correct assumptions no error occurs ?
            *)
            | _ => PFun C_Int "" []

        end 
        in
        
        (* build the body *)
        (* reprocess body with original œà + new f entry *)

        tr_b <- translate_fsl tr_term f bindings t_inf (upd_binding e) b ;;;

        let '(body_res_id,body_res_ty) as bres := tr_b.(res) in 
        (* body epilogue *)
        let bdecls := DECLS [bres] in
        let inits := INITS [bres] in 

        let code := tr_b.(tr).(chunk) in
        
        let rv := (C_Id body_res_id body_res_ty) in
        let cl := CLEARS [bres] in
        (* body prologue *)
        let ret_and_cleanup := match rtype with
        | C_Int =>  <{ cl ; return rv}>
        | T_Ext Mpz => 
            let setret : gmp_statement := Set_z retvar body_res_id
            in <{ setret ;  cl }>
        | _ => Skip end 
        in
        let body := <{ inits ; code ; ret_and_cleanup }> in 
        let gen_f := signature bdecls body in
        mkTR _ fres new_env (globals++[GFun gen_f]) (* function declarations is put with the other globals *)

    | None => ret (mkTR _ "fixme" e [])
    }
.

Hypothesis fixme :forall b, (term_size b < 0)%nat.

Solve Obligations with red ;red ; cbn ; auto with arith.
Next Obligation. red. red. cbn. now apply args_size_lt_in. Qed.
Next Obligation. red. red. cbn. auto with arith. Qed.
Next Obligation. red. red. cbn.  now apply args_size_lt_in. Qed.
Next Obligation. red. red. cbn.  auto with arith. Qed.
Next Obligation. red. red. cbn. apply fixme. Qed.
Final Obligation. red. red. cbn. apply fixme. Qed.



Definition translate_predicate := translate_fsl tr_pred.
Definition translate_term := translate_fsl tr_term.
Definition function_generation := translate_fsl f_gen.



(* Extraction "translation" translate_predicate translate_term function_generation. *)



Definition c_t_to_gmp_t (t:@_c_type Empty_set) : gmp_t := match t with
    | C_Int => C_Int
    | Void => Void
    | T_Ext False => Void (* not possible *)
    end
.

Definition c_decl_to_gmp_decl (d:@_c_decl Empty_set) : gmp_decl := 
    let '(C_Decl t id) := d in C_Decl (c_t_to_gmp_t t) id
.

Fixpoint c_exp_to_gmp_exp (e:c_exp) : gmp_exp := match e with
    | Zm z => Zm z
    | C_Id var t => C_Id var (c_t_to_gmp_t t) 
    | BinOpInt le op re => 
        let (le,re) := (c_exp_to_gmp_exp le,c_exp_to_gmp_exp re) in
        BinOpInt le op re
    | BinOpBool le op re => 
        let (le,re) := (c_exp_to_gmp_exp le,c_exp_to_gmp_exp re) in
        BinOpBool le op re
    end
.

(* translation of statements *)
Fixpoint translate_statement (f:fenv) (bindings : Œì·µ•) (t_inf : type_inf) (env: œà) (s : fsl_statement) : @state (@translation_result gmp_statement) := 
    match s with
    | S_Ext (LAssert p)  => 
        p_tr <- translate_predicate f bindings t_inf env p ;;;
        let d := DECLS p_tr.(decls) in
        let i := INITS p_tr.(decls) in
        let c := p_tr.(tr).(chunk gmp_statement) in
        let res := C_Id (fst p_tr.(res)) (snd p_tr.(res)) in
        let asrt := PAssert res in
        let clr := CLEARS p_tr.(decls) in 
        p_tr.(tr) 
            <| chunk := <{ i ;c ; asrt ; clr }> |> 
            <| glob ::= fun l => l ++ (map GDecl d) |> (* propagate global declarations *)
        
    
    | FCall x f args => 
        let args := map c_exp_to_gmp_exp args in 
        ret (mkTR gmp_statement (FCall x f args) env nil)


    | Seq s1 s2  => 
        s1_tr <- translate_statement f bindings t_inf env s1 ;;
        s2_tr <- translate_statement f bindings t_inf s1_tr.(tenv) s2 ;;;
        s2_tr <| chunk := Seq s1_tr.(chunk) s2_tr.(chunk) |> <| glob ::= app s1_tr.(glob) |>

    | If e s1 s2 => 
        let e := c_exp_to_gmp_exp e in 
        s1_tr <- translate_statement f bindings t_inf env s1 ;;
        s2_tr <- translate_statement f bindings t_inf s1_tr.(tenv) s2 ;;;
        s2_tr <| chunk := If e s1_tr.(chunk) s2_tr.(chunk) |> <| glob ::= app s1_tr.(glob) |>

    | While e b =>  
        let e := c_exp_to_gmp_exp e in 
        tr <- translate_statement f bindings t_inf env b ;;; 
        tr <| chunk := (While e tr.(chunk)) |>

    | Assign id e => ret (mkTR gmp_statement (Assign id (c_exp_to_gmp_exp e)) env nil)

    | PAssert e => 
        let e := c_exp_to_gmp_exp e in 
        ret (mkTR gmp_statement (PAssert e) env nil)
    | Return e => 
        let e := c_exp_to_gmp_exp e in 
        ret (mkTR gmp_statement (Return e) env nil)
    | PCall id args => let args := map c_exp_to_gmp_exp args in ret (mkTR gmp_statement (PCall id args) env nil)
    | Skip => ret (mkTR gmp_statement Skip env nil)
end.


Definition translate_program (f:fenv) (bindings : Œì·µ•) (t_inf : type_inf) (p: fsl_pgrm)  : rac_pgrm := 

    (* generate from left to right the globals and function definitions *)
    let res := List.fold_left (
        fun (done : @state ((list _ * list gmp_routine) * œà)%type) (doing:fsl_routine)  => 
            (* get the declarations, functions and last œà computed so far *)
            done_res <- done ;;
            let '((decls,funs) , env) := done_res in 

            match doing with 
            | PFun rtype name args decls body =>
                let args := map c_decl_to_gmp_decl args in 
                let decls := map c_decl_to_gmp_decl decls in 

                (* translate the body of the function, passing to it the last œà *)
                body_tr <- translate_statement f bindings t_inf env body ;;; 
                
                (* append the collect global vars from the body to fun decls ? *)
                let fdecls := decls ++ (fold_left ( fun acc g => 
                    match g with
                    | GDecl x => acc++[x]
                    | _ => acc
                    end
                    ) body_tr.(glob) []
                ) in 


                let tr_res := mkTR gmp_routine (PFun (c_t_to_gmp_t rtype) name args fdecls body_tr.(chunk))  body_tr.(tenv) body_tr.(glob) in

                (* appened to the end of the other functions the new translated one *)
                let funs := app funs [tr_res.(chunk)] in  
                ((decls,funs), tr_res.(tenv))

            | _ => 
                (* we only directly translate c functions *)
                (* article doesn't mention direct translation of logic functions / predicates but rather 
                    (possibly) generates them when they are called  
                    ->  are we supposed to fill up the function environment f ? 
                 *)
                ret done_res
            end
            
    ) (snd p) (ret ((map c_decl_to_gmp_decl (fst p),[]),(‚ä•:œà))) in

    
    fst (exec res) 
.