Require Import RAC.Definitions.
Require Import RAC.Notations.
Require Import RAC.Utils.
Require Import String.
Require Import BinaryString.
Open Scope string_scope.
Open Scope mini_c_scope.
Require Import List.
Import ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Export CounterMonad.
Require Import ZArith.ZArith.
Require Import BinaryString.
From RecordUpdate Require Import RecordUpdate.
Import RecordSetNotations.

Open Scope mini_gmp_scope.


(* macro definitions *)


Definition mpz_ASSGN v (e: gmp_exp ) : gmp_statement := match ty e with
    | T_Ext Mpz => match e with
                    | C_Id x _ => <( set_z(v,x) )>
                    | _ => Skip (* cannot happen *)
                    end
    | C_Int => <( set_i(v,e) )> : gmp_statement
    | _ => Skip (* cannot happen  *)
end.

Definition int_ASSGN v (e: gmp_exp) : gmp_statement := match ty e with
    | T_Ext Mpz => match e with
                    | C_Id x _ => <( v = get_int(x) )>
                    | _ => Skip (* cannot happen *)
                    end
    
    | C_Int =>  <{ v = e }>
    | _ => Skip
end.

Definition œÑ_ASSGN (t:gmp_t) := match t with
    | T_Ext Mpz => mpz_ASSGN
    | C_Int => int_ASSGN
    | _ => int_ASSGN (* cannot happen  *)
    end.

Definition Z_ASSGN (œÑz:gmp_t) v (z:Z) : gmp_statement := match œÑz with
    | C_Int => <{ v = z }>
    | T_Ext Mpz => <( set_s(v, (BinaryString.of_Z z) ) )>
    | _ => Skip (* cannot happen  *)
end.




Definition CMP c (e‚ÇÅ e‚ÇÇ : gmp_exp) v‚ÇÅ v‚ÇÇ : gmp_statement := match ty e‚ÇÅ, ty e‚ÇÇ with
    |  C_Int,C_Int => 
        <{ 
            if (e‚ÇÅ < e‚ÇÇ) c = 0-1
            else if (e‚ÇÅ > e‚ÇÇ) c = 1
            else c = 0
        }>
    | _,_ => 
        let a1 := mpz_ASSGN v‚ÇÅ e‚ÇÅ in 
        let a2 := mpz_ASSGN v‚ÇÇ e‚ÇÇ in
        let cmp : gmp_statement := <( c = cmp(v‚ÇÅ,v‚ÇÇ) )> in
        <{ a1 ; a2 ; cmp }>
end
.


Definition binop_ASSGN (fsl_op:fsl_binop_int) (v:ùì• ‚®â gmp_t) e‚ÇÅ e‚ÇÇ (r:id) v‚ÇÅ v‚ÇÇ : gmp_statement := 
    let (c,œÑ) := v in
    match œÑ,(ty e‚ÇÅ),(ty e‚ÇÇ) with
    | C_Int,C_Int,C_Int =>  let res := BinOpInt e‚ÇÅ (‚ñ° fsl_op) e‚ÇÇ in <{ c = res }>
    | _,_,_ => 
        let s1 :=  mpz_ASSGN v‚ÇÅ e‚ÇÅ in
        let s2 :=  mpz_ASSGN v‚ÇÇ e‚ÇÇ in
        let s3 : gmp_statement := match œÑ with
            | C_Int => 
                let op : gmp_statement  := <( (op fsl_op r v‚ÇÅ v‚ÇÇ) )> in
                let r : gmp_exp := (C_Id r (T_Ext Mpz)) in 
                <{op  ; <( (int_ASSGN c r) )> }>                    
            | T_Ext Mpz => op fsl_op c v‚ÇÅ v‚ÇÇ
            | _ => Skip
            end
        in <{s1;s2;s3}>

    end
    .


Definition var_list := (ùì• ‚®â gmp_t) ‚É∞.

(* helper functions *)
Definition DECLS (vars:var_list) : list gmp_decl := (* generates declarations *)
    List.fold_right (
        fun (v:ùì• ‚®â _) decls  => 
            let (s,t) := v in 
            (C_Decl t s) :: decls
    ) [] vars .

Definition INITS (vars : var_list) : gmp_statement := (* generates initialization *)
    List.fold_right 
    (
        fun (v:ùì• ‚®â _) a => let (z,t) := v in 
        match t with
        | C_Int => a
        | T_Ext Mpz => 
            let init : gmp_statement  := <( init(z) )> in 
            <{init ; a}>  
        | _ => Skip (* cannot happen  *)
        end      
    ) Skip vars.

Definition CLEARS (vars : var_list) : gmp_statement := (* generates deallocation *)
List.fold_right 
(
    fun (v:ùì• ‚®â _) a => let (z,t) := v in 
    match t with
    | T_Ext Mpz =>
        let cl : gmp_statement := <( cl(z) )> in 
        <{cl  ; a }>
    | C_Int | _  => a
    end        
) Skip vars.


Inductive global := GDecl (decl:gmp_decl) | GFun (f:gmp_routine).


Record translation_result {T : Type} := mkTR
{
    chunk: T ;  (* code chunk  resulting of the translation *)
    tenv: œà; (* global definitions i.e. routines generated by the translation *)
    glob:global ‚É∞ ; (* mini-c globals generated during translation (global var + routine) *)
}.
#[export] Instance etaTR {T : Type}: Settable _ := settable! (mkTR T) <chunk;tenv;glob>.


Record translated_statement {T: Type} := mkSTR
{
    tr : @translation_result T;

    (* fresh variables generated by the translation *)
    decls: var_list ;

    (* variable containing the result *)
    (* can't just be the varname because CMP expects an expression as 2nd and 3rd param 
        so we need both the id and type.
        Even though we only use C_Int most of the time, the oracle outputs gmp_t so it must be gmp_t
    *)
    res: ùì• * gmp_t;
}.
#[export] Instance etaSTR {T : Type}: Settable _ := settable! (mkSTR T) <tr;decls;res>.


Definition fresh_variable :=  c <- fresh ;;; ("_v" ++ string_of_nat c)%string. 

Definition fresh_fname id :=  c <- fresh ;;; ("_id" ++ id ++ string_of_nat c)%string. 



(* Since predicates are evaluated to 0 or 1, their result always fits in an int.*)

Fixpoint translate_predicate (f : fenv) (bindings:Œì·µ•) (t_inf : type_inf) (e: œà) (p: predicate) (fuel:nat) : state  := 
match fuel with | O => ret (mkSTR gmp_statement (mkTR gmp_statement Skip e nil) nil  ("",C_Int)) | S n =>

    match p with
    | P_True => 
        c <- fresh_variable ;;
        let decl := [(c,C_Int)] in
        let code := <{ c = 1 }> in
        ret (mkSTR gmp_statement (mkTR gmp_statement code e nil) decl (c,C_Int))
    | P_False => 
        c <- fresh_variable ;; 
        let decl := [(c,C_Int)] in
        let code := <{ c = 0 }> in
        ret (mkSTR gmp_statement (mkTR gmp_statement code e nil) decl  (c, C_Int))

    | P_Not p => 
        c <- fresh_variable ;; 
        p_tr <- translate_predicate f bindings t_inf e p n ;;;
        let _res := C_Id (fst p_tr.(res)) (snd p_tr.(res)) in
        let decl := (c,C_Int)::p_tr.(decls) in
        let code := <{ (p_tr.(tr).(chunk gmp_statement)) ; if _res c = 0 else c = 1 }> in
        mkSTR gmp_statement (mkTR gmp_statement code p_tr.(tr).(tenv gmp_statement) nil) decl (c, C_Int)
    
    | P_Disj p1 p2 => 
        c <- fresh_variable ;;
        tr_p1 <- translate_predicate f bindings t_inf e p1 n ;;
        let p1_res := C_Id (fst tr_p1.(res)) (snd tr_p1.(res)) in
        let p1_code := tr_p1.(tr).(chunk gmp_statement) in
        tr_p2 <- translate_predicate f bindings t_inf tr_p1.(tr).(tenv gmp_statement) p2  n;;;
        let p2_res := C_Id (fst tr_p2.(res)) (snd tr_p2.(res)) in
        let p2_code := tr_p2.(tr).(chunk gmp_statement) in
        let decl := (c,C_Int)::tr_p1.(decls) ++ tr_p2.(decls) in
        let code := <{ p1_code ; if p1_res c = 1 else <{ p2_code ; <{c = p2_res}> }> }> 
        in
        mkSTR gmp_statement (mkTR gmp_statement code tr_p2.(tr).(tenv gmp_statement) nil) decl  (c,C_Int)

    | P_BinOp t1 fsl_op t2 =>
        c <- fresh_variable ;;

        tr_t1 <- translate_term f bindings t_inf e t1 n ;;
        let t1_code := tr_t1.(tr).(chunk gmp_statement) in
        tr_t2 <- translate_term f bindings t_inf tr_t1.(tr).(tenv gmp_statement) t2  n;;
        let t2_code := tr_t2.(tr).(chunk gmp_statement) in

        let decl := ("v1", T_Ext Mpz)::("v2",T_Ext Mpz)::(c,C_Int)::tr_t1.(decls) ++ tr_t2.(decls) in

        let (ct1,tt1) := tr_t1.(res) in 
        let (ct2,tt2) := tr_t1.(res) in 
        let comp := CMP c (C_Id ct1 tt1) (C_Id ct2 tt2) "v1" "v2" in 

        let code := <{ t1_code ; t2_code; comp ; (Assign c (BinOpBool (C_Id c C_Int) (‚óñfsl_op) 0)) }>  in
        ret (mkSTR gmp_statement (mkTR gmp_statement code tr_t2.(tr).(tenv gmp_statement) []) decl  (c,C_Int))

    | P_Call pname args as call =>  
        match f.(preds) pname with 
        | None => (* shoudn't happen *)
            ret (mkSTR gmp_statement (mkTR gmp_statement Skip e nil) nil  ("",C_Int))
        | Some (params,_) =>
            (* value returned by the function call *)
            c <- fresh_variable ;;

            (* for each pair of function argument and parameter *)
            let f_res := fold_left2 ( fun done arg param => 
                done <- done ;;

                (* get current declarations, translation and bindings environment *)
                let '(curr_decls,curr_args_ids,curr_tr, binds) := done : (_ * _ * _) in 
                

                (* translate the argument *)
                (* fixme : doesn't detect decreasing *)
                t_tr <- translate_term f bindings t_inf curr_tr.(tenv) arg n ;;
                (* let t_tr := mkSTR gmp_statement (mkTR _ Skip e nil) ([]:var_list ) (c,C_Int) in   *)

                let new_tr := curr_tr 
                    <| tenv := t_tr.(tr).(tenv) |> (* pass the updated env *)
                    <| chunk ::= fun s => Seq s t_tr.(tr).(chunk) |> (* append the code generated by the translation of t*)
                    <| glob ::= fun globs => app globs t_tr.(tr).(glob) |> (* append the new globals *)
                in 

                (* building the fresh binding env for parameters *)
                v <- fresh_variable ;;;
                let interval := t_inf.(oracle) arg t_inf.(t_env)  in

                (* collect and append  *)
                ( 
                    curr_decls ++ t_tr.(decls), (* the new fresh variables from the translation of the argument *)
                    curr_args_ids ++ [C_Id (fst t_tr.(res)) (snd t_tr.(res))], (* the variable used to represent the argument *)
                    new_tr, (* the updated function translation  *)
                    binds{param\(v,interval)} (* the updated bindings *)
                )

            ) (ret ([(c,C_Int)], ([] : list _c_exp), mkTR gmp_statement Skip e [], ‚ä•)) args params  in

            
            f_res <- f_res ;;

            let '(decls,params_id,f_tr,binds) := f_res in 
            
            (* last env needed for function generation *)
            let last_env := f_tr.(tenv) in 

            (* get specialized function name, env and globals  *)
            gf <- match e (pname,t_inf.(t_env)) with
            (* function already exists for current binders, no generation required, 
                env is the same as the current one 
                no new globals 
            *)
            | Some name => ret (name,e,[]) 
            | None => (* no function specialized for those binders, generate a new one *)
                new_f <- function_generation f binds t_inf last_env pname n ;;;
                (* one new global : the function declaration itself *)
                (new_f.(chunk), new_f.(tenv), new_f.(glob))
            end ;;;

            let '(gf_name,gf_env,gf_globs) := gf in  
            
            (* append function globals to the globals *)
            let globs := f_tr.(glob) ++ gf_globs in

            (* return value *)
            let res := (c,C_Int) (* c is int because return value is either 0 or 1 *) in 

            (* create calling code *)
            let code := PCall gf_name params_id in

            mkSTR gmp_statement (mkTR _ code gf_env globs) decls res
        end 
    end
end

with translate_term (f : @fenv _fsl_statement Empty_set) (bindings : Œì·µ•) (t_inf : type_inf) (e: œà) (t : fsl_term) (fuel:nat) {struct fuel}
    : @state translated_statement := 

match fuel with | O => ret (mkSTR gmp_statement (mkTR gmp_statement Skip e nil) nil  ("",C_Int)) | S n =>
    match t with
    | T_Id v FSL_Int => (* program variable *)
        ret (mkSTR gmp_statement (mkTR gmp_statement Skip e nil) nil (v,C_Int))

    | T_Id v FSL_Integer => (* logic var *)
        let res := match bindings v with 
            (*  bindings v necessarily succeeds (section 4.5.)... *)
            | Some x => fst x
            | None => "fixme"
        end  
        in 
        ret (mkSTR gmp_statement (mkTR gmp_statement Skip e nil) nil (v,T_Ext Mpz))

    | T_Z z =>
        let œÑ := ùö™ t_inf.(oracle) t_inf.(i_op) z t_inf.(t_env) in
        c <- fresh_variable ;;
        let decl := [(c,œÑ)]  in 
        let code := Z_ASSGN C_Int c z in
        ret (mkSTR gmp_statement (mkTR gmp_statement code e nil) decl (c,C_Int))

    | T_BinOp t1 _op t2 => 
        let œÑ := ùö™ t_inf.(oracle) t_inf.(i_op) (T_BinOp t1 _op t2) t_inf.(t_env) in
        c <- fresh_variable ;;
        v1 <- fresh_variable ;;
        v2 <- fresh_variable ;;
        r <- fresh_variable ;;
        t1_tr <- translate_term f bindings t_inf e t1  n ;; 
        let t1_code := t1_tr.(tr).(chunk gmp_statement) in
        let t1_res := C_Id (fst t1_tr.(res)) (snd t1_tr.(res)) in
        t2_tr <- translate_term f bindings t_inf t1_tr.(tr).(tenv gmp_statement) t2  n;; 
        let t2_code := t2_tr.(tr).(chunk gmp_statement) in
        let t2_res :=  C_Id (fst t2_tr.(res)) (snd t2_tr.(res)) in
        let decl := (c,œÑ) :: (v1,T_Ext Mpz) :: (v2,T_Ext Mpz) :: (r,T_Ext Mpz) :: t1_tr.(decls) ++ t2_tr.(decls) in
        let assgn := binop_ASSGN _op (c,œÑ) t1_res t2_res r v1 v2 in
        let code := <{ t1_code ; t2_code ; assgn }> in
        ret (mkSTR gmp_statement (mkTR gmp_statement code t2_tr.(tr).(tenv gmp_statement) nil) decl (c,C_Int))

    | T_Cond p t1 t2 as cond => 
        c <- fresh_variable ;;
        let œÑ := ùö™ t_inf.(oracle) t_inf.(i_op) cond t_inf.(t_env) in
        p_tr <- translate_predicate f bindings t_inf e p n ;;
        t1_tr <- translate_term f bindings t_inf p_tr.(tr).(tenv gmp_statement) t1  n ;; 
        let t1_code := t1_tr.(tr).(chunk gmp_statement) in
        let t1_res := C_Id (fst t1_tr.(res)) (snd t1_tr.(res))  in
        t2_tr <- translate_term f bindings t_inf t1_tr.(tr).(tenv gmp_statement) t2  n;;;
        let t2_code := t2_tr.(tr).(chunk gmp_statement) in
        let t2_res := C_Id (fst t2_tr.(res)) (snd t2_tr.(res)) in
        let p_code  := p_tr.(tr).(chunk gmp_statement) in 
        let p_res := C_Id (fst p_tr.(res)) (snd p_tr.(res)) in
        let t1_assgn := œÑ_ASSGN œÑ c t1_res in
        let t2_assgn := œÑ_ASSGN œÑ c t2_res in
        let decl := (c,œÑ) :: p_tr.(decls) ++ t1_tr.(decls) ++ t2_tr.(decls) in
        let code := 
            <{
                p_code;
                if (p_res) <{ t1_code ; t1_assgn}> 
                else <{t2_code ; t2_assgn }>
            }> in
        mkSTR gmp_statement (mkTR gmp_statement code t2_tr.(tr).(tenv gmp_statement) nil) decl  (c,C_Int)

    | T_Call fname args as call =>  
        match f.(lfuns) fname with 
        | None => (* shoudn't happen *)
            ret (mkSTR gmp_statement (mkTR gmp_statement Skip e nil) nil  ("",C_Int))
        | Some (params,_) =>

            let rtype :=  ùö™ t_inf.(oracle) t_inf.(i_op) call t_inf.(t_env) in 
            
            (* value returned by the function call *)
            c <- fresh_variable ;;

            (* for each pair of function argument and parameter *)
            let f_res := fold_left2 ( fun done arg param => 
                done <- done ;;

                (* get current declarations, translation and bindings environment *)
                let '(curr_decls,curr_args_ids,curr_tr, binds) := done : (_ * _ * _) in 
                

                (* translate the argument *)
                (* fixme : doesn't detect decreasing *)
                t_tr <- translate_term f bindings t_inf curr_tr.(tenv) arg n ;;
                (* let t_tr := mkSTR gmp_statement (mkTR _ Skip e nil) ([]:var_list ) (c,C_Int) in   *)

                let new_tr := curr_tr 
                    <| tenv := t_tr.(tr).(tenv) |> (* pass the updated env *)
                    <| chunk ::= fun s => Seq s t_tr.(tr).(chunk) |> (* append the code generated by the translation of t*)
                    <| glob ::= fun globs => app globs t_tr.(tr).(glob) |> (* append the new globals *)
                in 

                (* building the fresh binding env for parameters *)
                v <- fresh_variable ;;;
                let interval := t_inf.(oracle) arg t_inf.(t_env)  in

                (* collect and append  *)
                ( 
                    curr_decls ++ t_tr.(decls), (* the new fresh variables from the translation of the argument *)
                    curr_args_ids ++ [C_Id (fst t_tr.(res)) (snd t_tr.(res))], (* the variable used to represent the argument *)
                    new_tr, (* the updated function translation  *)
                    binds{param\(v,interval)} (* the updated bindings *)
                )

            ) (ret ([(c,rtype)], ([] : list _c_exp), mkTR gmp_statement Skip e [], ‚ä•)) args params  in

            
            f_res <- f_res ;;

            let '(decls,params_id,f_tr,binds) := f_res in 
            
            (* last env needed for function generation *)
            let last_env := f_tr.(tenv) in 

            (* get specialized function name, env and globals  *)
            gf <- match e (fname,t_inf.(t_env)) with
            (* function already exists for current binders, no generation required, 
                env is the same as the current one 
                no new globals 
            *)
            | Some name => ret (name,e,[]) 
            | None => (* no function specialized for those binders, generate a new one *)
                new_f <- function_generation f binds t_inf last_env fname n ;;;
                (* one new global : the function declaration itself *)
                (new_f.(chunk), new_f.(tenv), new_f.(glob))
            end ;;;

            let '(gf_name,gf_env,gf_globs) := gf in  
            
            (* append function globals to the globals *)
            let globs := f_tr.(glob) ++ gf_globs in

            (* return value *)
            let res := (c,C_Int) (*fixme : what type is c ? *) in 

            (* create calling code *)
            let code : gmp_statement := match rtype with
                | C_Int => FCall c gf_name params_id
                | T_Ext (Mpz) => 
                    let firstparam := C_Id (fst res) (snd res) in 
                    PCall gf_name (firstparam :: params_id)
                | _ => Skip (* not possible *)
            end in



            mkSTR gmp_statement (mkTR _ code gf_env globs) decls res
        end
    end 
end
with function_generation (f:@fenv _fsl_statement Empty_set) (bindings:  Œì·µ•) (t_inf : type_inf) (env: œà) (fname: id) (fuel:nat) {struct fuel}
: @state (@translation_result ùì•) := 
match fuel with | O => ret (mkTR _ "fixme" env []) | S n =>
    match f.(lfuns) fname with
    | Some (params,b) => 
        (* get the return type *)
        let rtype := ùö™ t_inf.(oracle) t_inf.(i_op) b t_inf.(t_env) in

        (* generate a fresh name for the new function *)
        fres <- fresh_fname fname;;

        (* process body *)

        (* fixme : cannot guess decreasing argument of fix*)
        tr_b <- translate_term f bindings t_inf env b n ;;
        (* tr_b <- ret (mkSTR gmp_statement (mkTR _ Skip env nil) ([]:var_list ) ("",C_Int)) ;;  *)

        (* global declarations generated by the body , appended before function declaration  *)
        let globals := tr_b.(tr).(glob) in

        (* prepare env update : 
            indexed by the original name of the function and what binders interval Œì·µ¢ it is for ;
            returns the unique generated function id for those binders
        *)
        let upd_binding := {{(fname,(t_inf.(t_env)))\fres}} in

        let new_env := upd_binding tr_b.(tr).(tenv) in        

        (* in case the result is too big to fit in a machine integer *)
        let retvar := "_ret" in

        (*  build the signature of the function *)
        let signature : list _c_decl   -> _c_statement -> gmp_routine := 
            (* figure out the type and id of parameters *)
            let params := map (fun p => 
                let i := match t_inf.(t_env) p with
                    | Some i => i 
                    | None => mkInterval 0 0 (*fixme:  guarantee var is present in inference env  *)
                    end
                in
                (* get the corresponding id *)
                let v := match bindings p with Some (v,_) => v | None => "fixme" end in

                C_Decl (t_inf.(i_op) i) v
            ) params in 

            match rtype with
            | C_Int => PFun C_Int fres params
            (* if rtype is mpz, pass function result using first argument *)
            | T_Ext Mpz  => PFun Void fres ((C_Decl (T_Ext Mpz) retvar)::params)
            (* can't happen ... 
                thought : 
                use error monad everywhere to handle those and prove under correct assumptions no error occurs ?
            *)
            | _ => PFun C_Int "" []

        end 
        in
        
        (* build the body *)
        (* reprocess body with original œà + new f entry *)

        (* fixme : Cannot guess decreasing argument of fix. *)
        tr_b <- translate_term f bindings t_inf (upd_binding env) b n;;;
        (* tr_b <- ret (mkSTR gmp_statement (mkTR _ Skip env nil) ([]:var_list ) ("",C_Int)) ;;; *)

        let '(body_res_id,body_res_ty) as bres := tr_b.(res) in 
        (* body epilogue *)
        let bdecls := DECLS [bres] in
        let inits := INITS [bres] in 

        let code := tr_b.(tr).(chunk) in
        
        let rv := (C_Id body_res_id body_res_ty) in
        let cl := CLEARS [bres] in
        (* body prologue *)
        let ret_and_cleanup := match rtype with
        | C_Int =>  <{ cl ; return rv}>
        | T_Ext Mpz => 
            let setret : gmp_statement := Set_z retvar body_res_id
            in <{ setret ;  cl }>
        | _ => Skip end 
        in
        let body := <{ inits ; code ; ret_and_cleanup }> in 
        let gen_f := signature bdecls body in
        mkTR _ fres new_env (globals++[GFun gen_f]) (* function declarations is put with the other globals *)

    | None => ret (mkTR _ "fixme" env [])
    end 
end
.



Definition c_t_to_gmp_t (t:@_c_type Empty_set) : gmp_t := match t with
    | C_Int => C_Int
    | Void => Void
    | T_Ext False => Void (* not possible *)
    end
.

Definition c_decl_to_gmp_decl (d:@_c_decl Empty_set) : gmp_decl := 
    let '(C_Decl t id) := d in C_Decl (c_t_to_gmp_t t) id
.

Fixpoint c_exp_to_gmp_exp (e:c_exp) : gmp_exp := match e with
    | Zm z => Zm z
    | C_Id var t => C_Id var (c_t_to_gmp_t t) 
    | BinOpInt le op re => 
        let (le,re) := (c_exp_to_gmp_exp le,c_exp_to_gmp_exp re) in
        BinOpInt le op re
    | BinOpBool le op re => 
        let (le,re) := (c_exp_to_gmp_exp le,c_exp_to_gmp_exp re) in
        BinOpBool le op re
    end
.

(* translation of statements *)
Fixpoint translate_statement (f:fenv) (bindings : Œì·µ•) (t_inf : type_inf) (env: œà) (s : fsl_statement) : @state (@translation_result gmp_statement) := 
    match s with
    | S_Ext (LAssert p)  => 
        p_tr <- translate_predicate f bindings t_inf env p 100;;;
        let d := DECLS p_tr.(decls) in
        let i := INITS p_tr.(decls) in
        let c := p_tr.(tr).(chunk gmp_statement) in
        let res := C_Id (fst p_tr.(res)) (snd p_tr.(res)) in
        let asrt := PAssert res in
        let clr := CLEARS p_tr.(decls) in 
        p_tr.(tr) 
            <| chunk := <{ i ;c ; asrt ; clr }> |> 
            <| glob ::= fun l => l ++ (map GDecl d) |> (* propagate global declarations *)
        
    
    | FCall x f args => 
        let args := map c_exp_to_gmp_exp args in 
        ret (mkTR gmp_statement (FCall x f args) env nil)


    | Seq s1 s2  => 
        s1_tr <- translate_statement f bindings t_inf env s1 ;;
        s2_tr <- translate_statement f bindings t_inf s1_tr.(tenv) s2 ;;;
        s2_tr <| chunk := Seq s1_tr.(chunk) s2_tr.(chunk) |> <| glob ::= app s1_tr.(glob) |>

    | If e s1 s2 => 
        let e := c_exp_to_gmp_exp e in 
        s1_tr <- translate_statement f bindings t_inf env s1 ;;
        s2_tr <- translate_statement f bindings t_inf s1_tr.(tenv) s2 ;;;
        s2_tr <| chunk := If e s1_tr.(chunk) s2_tr.(chunk) |> <| glob ::= app s1_tr.(glob) |>

    | While e b =>  
        let e := c_exp_to_gmp_exp e in 
        tr <- translate_statement f bindings t_inf env b ;;; 
        tr <| chunk := (While e tr.(chunk)) |>

    | Assign id e => ret (mkTR gmp_statement (Assign id (c_exp_to_gmp_exp e)) env nil)

    | PAssert e => 
        let e := c_exp_to_gmp_exp e in 
        ret (mkTR gmp_statement (PAssert e) env nil)
    | Return e => 
        let e := c_exp_to_gmp_exp e in 
        ret (mkTR gmp_statement (Return e) env nil)
    | PCall id args => let args := map c_exp_to_gmp_exp args in ret (mkTR gmp_statement (PCall id args) env nil)
    | Skip => ret (mkTR gmp_statement Skip env nil)
end.


Definition translate_program (f:fenv) (bindings : Œì·µ•) (t_inf : type_inf) (p: fsl_pgrm)  : rac_pgrm := 

    (* generate from left to right the globals and function definitions *)
    let res := List.fold_left (
        fun (done : @state ((list _ * list gmp_routine) * œà)%type) (doing:fsl_routine)  => 
            (* get the declarations, functions and last œà computed so far *)
            done_res <- done ;;
            let '((decls,funs) , env) := done_res in 

            match doing with 
            | PFun rtype name args decls body =>
                let args := map c_decl_to_gmp_decl args in 
                let decls := map c_decl_to_gmp_decl decls in 

                (* translate the body of the function, passing to it the last œà *)
                body_tr <- translate_statement f bindings t_inf env body ;;; 
                
                (* append the collect global vars from the body to fun decls ? *)
                let fdecls := decls ++ (fold_left ( fun acc g => 
                    match g with
                    | GDecl x => acc++[x]
                    | _ => acc
                    end
                    ) body_tr.(glob) []
                ) in 


                let tr_res := mkTR gmp_routine (PFun (c_t_to_gmp_t rtype) name args fdecls body_tr.(chunk))  body_tr.(tenv) body_tr.(glob) in

                (* appened to the end of the other functions the new translated one *)
                let funs := app funs [tr_res.(chunk)] in  
                ((decls,funs), tr_res.(tenv))

            | _ => 
                (* we only directly translate c functions *)
                (* article doesn't mention direct translation of logic functions / predicates but rather 
                    (possibly) generates them when they are called  
                    ->  are we supposed to fill up the function environment f ? 
                 *)
                ret done_res
            end
            
    ) (snd p) (ret ((map c_decl_to_gmp_decl (fst p),[]),(‚ä•:œà))) in

    
    fst (exec res) 
.