Require Import RAC.Definitions.
Require Import RAC.Notations.
Require Import RAC.Utils.
Require Import String.
Require Import BinaryString.
Open Scope string_scope.
Open Scope mini_c_scope.
Require Import List.
Import ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Export CounterMonad.
Require Import ZArith.ZArith.
Require Import BinaryString.
From RecordUpdate Require Import RecordUpdate.
Import RecordSetNotations.

Open Scope mini_gmp_scope.


(* macro definitions *)


Definition mpz_ASSGN v (e: gmp_exp ) : gmp_statement := match ty e with
    | T_Ext Mpz => match e with
                    | C_Id x _ => <( set_z(v,x) )>
                    | _ => Skip (* cannot happen *)
                    end
    | C_Int => <( set_i(v,e) )>
    | _ => Skip
end.

Definition int_ASSGN v (e: gmp_exp) : gmp_statement := match ty e with
    | T_Ext Mpz => match e with
                    | C_Id x _ => <( v = get_int(x) )>
                    | _ => Skip (* cannot happen *)
                    end
    
    | C_Int =>  <{ v = e }>
    | _ => Skip
end.

Definition τ_ASSGN t := match t with
    | T_Ext Mpz => mpz_ASSGN
    | C_Int => int_ASSGN
    | _ => int_ASSGN (* fixme  *)
    end.

Definition Z_ASSGN (τz:gmp_t) v (z:Z) : gmp_statement := match τz with
    | C_Int => <{ v = z }>
    | T_Ext Mpz => <( set_s(v, (BinaryString.of_Z z) ) )>
    | _ => Skip
end.




Definition CMP c e₁ e₂ v₁ v₂ : gmp_statement := match ty e₁, ty e₂ with
    |  C_Int,C_Int => 
        <{ 
            if (e₁ < e₂) c = 0-1
            else if (e₁ > e₂) c = 1
            else c = 0
        }>
    | _,_ => 
        let a1 := mpz_ASSGN v₁ e₁ in 
        let a2 := mpz_ASSGN v₂ e₂ in
        <{ a1 ; a2 ; <( c = cmp(v₁,v₂) )> }>
end
.


Definition binop_ASSGN (fsl_op:fsl_binop_int) (v:𝓥 ⨉ gmp_t) e₁ e₂ (r:id) v₁ v₂ : gmp_statement := 
    let (c,τ) := v in
    match τ,(ty e₁),(ty e₂) with
    | C_Int,C_Int,C_Int =>  let res := BinOpInt e₁ (□ fsl_op) e₂ in <{ c = res }>
    | _,_,_ => 
        let s1 :=  mpz_ASSGN v₁ e₁ in
        let s2 :=  mpz_ASSGN v₂ e₂ in
        let s3 := match τ with
             | C_Int => <{ <( (op fsl_op r v₁ v₂) )> ; <( (int_ASSGN c (C_Id r Mpz)) )> }>                    
             | T_Ext Mpz => op fsl_op c v₁ v₂
                    | _ => Skip
                    end
        in <{s1;s2;s3}>

    end
    .


Definition var_list := (𝓥 ⨉ gmp_t ) ⃰.


(* helper functions *)
Definition DECLS (vars:var_list) : gmp_statement := (* generates declarations *)
    List.fold_right (
        fun (v:𝓥 ⨉ gmp_t) a => 
            let (s,t) := v in 
            let decl := GMP_Decl t s in <{ decl ; a}>
    ) Skip vars.

Definition INITS (vars : var_list) : gmp_statement := (* generates initialization *)
    List.fold_right 
    (
        fun (v:𝓥 ⨉ gmp_t) a => let (z,t) := v in 
        match t with
        | T_Ext Mpz => <{ <( init(z) )> ; a}>
        | C_Int  => a
        | _ => Skip
        end        
    ) Skip vars.

Definition CLEARS (vars : var_list) : gmp_statement := (* generates deallocation *)
List.fold_right 
(
    fun (v:𝓥 ⨉ gmp_t) a => let (z,t) := v in 
    match t with
    | T_Ext Mpz => <{ <( cl(z) )> ; a }>
    | C_Int | _  => a
    end        
) Skip vars.



Record translation_result {T : Type} := mkTR
{
    chunk: T ;  (* code chunk  resulting of the translation *)
    tenv: ψ; (* global definitions i.e. routines generated by the translation *)
    glob:gmp_decl ⃰ ; (* mini-c globals generated during translation *)
}.
#[export] Instance etaTR {T : Type}: Settable _ := settable! (mkTR T) <chunk;tenv;glob>.


Record translated_statement {T: Type} := mkSTR
{
    tr : @translation_result T;

    (* fresh variables generated by the translation *)
    decls: var_list ;

    (* variable containing the result *)
    (* can't just be the varname because CMP expects an expression as 2nd and 3rd param 
        so we need both the id and type even though it looks like the type is always C_Int
    *)
    res: 𝓥 * gmp_t   ;
}.
#[export] Instance etaSTR {T : Type}: Settable _ := settable! (mkSTR T) <tr;decls;res>.


Definition fresh_variable :=  c <- fresh ;;; ("_v" ++ string_of_nat c)%string. 

(* Since predicates are evaluated to 0 or 1, their result always fits in an int.*)


Fixpoint translate_predicate (bindings:Γᵥ) (t_inf : type_inf) (e: ψ) (p: predicate) : state  := match p with
    | P_True => 
        c <- fresh_variable ;;
        let decl := [(c,C_Int)] in
        let code := <{ c = 1 }> in
        ret (mkSTR gmp_statement (mkTR gmp_statement code e nil) decl (c,C_Int))
    | P_False => 
        c <- fresh_variable ;; 
        let decl := [(c,C_Int)] in
        let code := <{ c = 0 }> in
        ret (mkSTR gmp_statement (mkTR gmp_statement code e nil) decl  (c, C_Int))

    | Not p => 
        c <- fresh_variable ;; 
        p_tr <- translate_predicate bindings t_inf e p ;;;
        let _res := C_Id (fst p_tr.(res)) (snd p_tr.(res)) in
        let decl := (c,C_Int)::p_tr.(decls) in
        let code := <{ (p_tr.(tr).(chunk gmp_statement)) ; if _res c = 0 else c = 1 }> in
        mkSTR gmp_statement (mkTR gmp_statement code p_tr.(tr).(tenv gmp_statement) nil) decl (c, C_Int)
    
    | Disj p1 p2 => 
        c <- fresh_variable ;;
        tr_p1 <- translate_predicate bindings t_inf e p1 ;;
        let p1_res := C_Id (fst tr_p1.(res)) (snd tr_p1.(res)) in
        let p1_code := tr_p1.(tr).(chunk gmp_statement) in
        tr_p2 <- translate_predicate bindings t_inf tr_p1.(tr).(tenv gmp_statement) p2 ;;;
        let p2_res := C_Id (fst tr_p2.(res)) (snd tr_p2.(res)) in
        let p2_code := tr_p2.(tr).(chunk gmp_statement) in
        let decl := (c,C_Int)::tr_p1.(decls) ++ tr_p2.(decls) in
        let code := <{ p1_code ; if p1_res c = 1 else <{ p2_code ; <{c = p2_res}> }> }> 
        in
        mkSTR gmp_statement (mkTR gmp_statement code tr_p2.(tr).(tenv gmp_statement) nil) decl  (c,C_Int)

    | P_BinOp t1 fsl_op t2 =>
        c <- fresh_variable ;;

        tr_t1 <- translate_term bindings t_inf e t1 ;;
        let t1_code := tr_t1.(tr).(chunk gmp_statement) in
        tr_t2 <- translate_term bindings t_inf tr_t1.(tr).(tenv gmp_statement) t2 ;;
        let t2_code := tr_t2.(tr).(chunk gmp_statement) in

        let decl := ("v1",T_Ext Mpz)::("v2",T_Ext Mpz)::(c,C_Int)::tr_t1.(decls) ++ tr_t2.(decls) in

        let (ct1,tt1) := tr_t1.(res) in 
        let (ct2,tt2) := tr_t1.(res) in 
        let comp := CMP c (C_Id ct1 tt1) (C_Id ct2 tt2) "v1" "v2" in 

        let code := <{ t1_code ; t2_code; comp ; (Assign c (BinOpBool (C_Id c C_Int) (◖fsl_op) 0)) }>  in
        ret (mkSTR gmp_statement (mkTR gmp_statement code tr_t2.(tr).(tenv gmp_statement) nil) decl  (c,C_Int))

    | Call _ _ =>  
        (* todo handle predicate and logic function calls with logic_function_generation (5.3.) *)
        let _ := translate_term in
         ret (mkSTR gmp_statement (mkTR gmp_statement Skip e nil) nil  ("",C_Int))
end 

with translate_term (bindings : Γᵥ) (t_inf : type_inf) (e: ψ) (t : fsl_term) : state := match t with
    | T_Id v => 
        let res := match bindings v with 
            (* if v is a logic var, bindings v necessarily succeeds (section 4.5.)... *)
            | Some x => fst x
            | None => v (*  ... so if it fails, v must be a program variable *)
        end  
        in 
        ret (mkSTR gmp_statement (mkTR gmp_statement Skip e nil) nil  (v,C_Int))

    | T_Z z =>
        let τ := 𝚪 t_inf.(oracle) t_inf.(i_op) z t_inf.(t_env) in
        c <- fresh_variable ;;
        let decl := [(c,τ)]  in 
        let code := Z_ASSGN C_Int c z in
        ret (mkSTR gmp_statement (mkTR gmp_statement code e nil) decl (c,C_Int))

    | T_BinOp t1 _op t2 => 
        let τ := 𝚪 t_inf.(oracle) t_inf.(i_op) (T_BinOp t1 _op t2) t_inf.(t_env) in
        c <- fresh_variable ;;
        v1 <- fresh_variable ;;
        v2 <- fresh_variable ;;
        r <- fresh_variable ;;
        t1_tr <- translate_term bindings t_inf e t1 ;; 
        let t1_code := t1_tr.(tr).(chunk gmp_statement) in
        let t1_res := C_Id (fst t1_tr.(res)) (snd t1_tr.(res)) in
        t2_tr <- translate_term bindings t_inf t1_tr.(tr).(tenv gmp_statement) t2 ;; 
        let t2_code := t2_tr.(tr).(chunk gmp_statement) in
        let t2_res :=  C_Id (fst t2_tr.(res)) (snd t2_tr.(res)) in
        let decl := (c,τ) :: (v1,T_Ext Mpz) :: (v2,T_Ext Mpz) :: (r,T_Ext Mpz) :: t1_tr.(decls) ++ t2_tr.(decls) in
        let assgn := binop_ASSGN _op (c,τ) t1_res t2_res r v1 v2 in
        let code := <{ t1_code ; t2_code ; assgn }> in
        ret (mkSTR gmp_statement (mkTR gmp_statement code t2_tr.(tr).(tenv gmp_statement) nil) decl (c,C_Int))

    | T_Cond p t1 t2 => 
        c <- fresh_variable ;;
        let τ := 𝚪 t_inf.(oracle) t_inf.(i_op) (T_Cond p t1 t2) t_inf.(t_env) in
        p_tr <- translate_predicate bindings t_inf e p ;;
        t1_tr <- translate_term bindings t_inf p_tr.(tr).(tenv gmp_statement) t1 ;; 
        let t1_code := t1_tr.(tr).(chunk gmp_statement) in
        let t1_res := C_Id (fst t1_tr.(res)) (snd t1_tr.(res))  in
        t2_tr <- translate_term bindings t_inf t1_tr.(tr).(tenv gmp_statement) t2 ;;;
        let t2_code := t2_tr.(tr).(chunk gmp_statement) in
        let t2_res := C_Id (fst t2_tr.(res)) (snd t2_tr.(res)) in
        let p_code  := p_tr.(tr).(chunk gmp_statement) in 
        let p_res := C_Id (fst p_tr.(res)) (snd p_tr.(res)) in
        let t1_assgn := τ_ASSGN τ c t1_res in
        let t2_assgn := τ_ASSGN τ c t2_res in
        let decl := (c,τ) :: p_tr.(decls) ++ t1_tr.(decls) ++ t2_tr.(decls) in
        let code := 
            <{
                p_code;
                if (p_res) <{ t1_code ; t1_assgn}> 
                else <{t2_code ; t2_assgn }>
            }> in
        mkSTR gmp_statement (mkTR gmp_statement code t2_tr.(tr).(tenv gmp_statement) nil) decl  (c,C_Int)
    end
.

(* translation of statements *)
Fixpoint translate_statement (bindings : Γᵥ) (t_inf : type_inf) (env: ψ) (s : fsl_statement) : @state translation_result := match s with
    | S_Ext (LAssert p)  => 
        p_tr <- translate_predicate bindings t_inf env p ;;;
        let d := DECLS p_tr.(decls) in
        let i := INITS p_tr.(decls) in
        let c := p_tr.(tr).(chunk gmp_statement) in
        let res := C_Id (fst p_tr.(res)) (snd p_tr.(res)) in
        let asrt := PAssert res in
        let clr := CLEARS p_tr.(decls) in 
        p_tr.(tr) <| chunk := <{ d ; i ;c ; asrt ; clr }> |>
        
    
    | FCall x f args => ret (mkTR gmp_statement (FCall x f args) env nil)


    | Seq s1 s2  => 
        s1_tr <- translate_statement bindings t_inf env s1 ;;
        s2_tr <- translate_statement bindings t_inf s1_tr.(tenv) s2 ;;;
        s2_tr <| chunk := Seq s1_tr.(chunk) s2_tr.(chunk) |> <| glob ::= app s1_tr.(glob) |>

    | If e s1 s2 => 
        s1_tr <- translate_statement bindings t_inf env s1 ;;
        s2_tr <- translate_statement bindings t_inf s1_tr.(tenv) s2 ;;;
        s2_tr <| chunk := If e s1_tr.(chunk) s2_tr.(chunk) |> <| glob ::= app s1_tr.(glob) |>

    | While e b =>  
        tr <- translate_statement bindings t_inf env b ;;; 
        tr <| chunk := (While e tr.(chunk)) |>

    | Assign id e => ret (mkTR gmp_statement (Assign id e) env nil)


    | PAssert e => ret (mkTR gmp_statement (PAssert e) env nil)
    | Return e => ret (mkTR gmp_statement (Return e) env nil)
    | PCall id args => ret (mkTR gmp_statement (PCall id args) env nil)
    | Skip => ret (mkTR gmp_statement Skip env nil)
end.

Definition fresh_fname id :=  c <- fresh ;;; ("_id" ++ id ++ string_of_nat c)%string. 


Definition logic_function_generation (bindings:  Γᵥ) (t_inf : type_inf) (env: ψ) (funs: @𝔉) (f: id) : state := 
    match funs f with
    | Some (params,b) => 
        (* get the return type *)
        let rtype := 𝚪 t_inf.(oracle) t_inf.(i_op) b t_inf.(t_env) in

        (* generate a fresh name for the function *)
        fname <- fresh_fname f;;

        (* process body *)
        tr_b <- translate_term bindings t_inf env b ;;

        (* global declarations generated by the body *)
        let globals := tr_b.(tr).(glob) in

        (* prepare env update *)
        let upd_binding := {{(f,(t_inf.(t_env)))\fname}} in

        let new_env := upd_binding tr_b.(tr).(tenv) in
        
        (* in case the result is too big to fit in an machine integer *)
        let retvar := "_ret" in

        (*  build the signature of the function *)
        let signature := 
            (* figure out the type and id of parameters *)
            let params := map (fun p => 
                let i := match t_inf.(t_env) p with
                    | Some i => i 
                    | None => mkInterval 0 0 (*fixme:  guarantee var is present in inference env  *)
                    end
                in
                (* get the corresponding id *)
                let v := match bindings p with Some (v,_) => v | None => "" end in

                C_Decl (t_inf.(i_op) i) v
            ) params in 

            (* if rtype is mpz, pass function result using first argument *)
            match rtype with
            | C_Int => PFun C_Int fname params
            | T_Ext Mpz  => PFun Void fname ((C_Decl (T_Ext Mpz) retvar)::params)
            (* can't happen ... 
                thought : 
                use error monad everywhere to handle those and prove under correct assumptions no error occurs ?
            *)
            | _ => PFun C_Int "" []

        end 
        in
        (* build the body *)
        (* reprocess body with updated ψ *)
        tr_b <- translate_term bindings t_inf (upd_binding env) b ;;;

        let res := tr_b.(res) in 
        (* body epilogue *)
        let bdecls := DECLS [res] in
        let inits := INITS [res] in 

        let code := tr_b.(tr).(chunk) in
        
        let rv := (C_Id (fst res) (snd res)) in
        let cl := CLEARS [res] in
        (* body prologue *)
        let ret_and_cleanup := match rtype with
        | C_Int =>  <{ cl ; return rv}>
        | T_Ext Mpz => 
            let setret := Set_z retvar (fst res)
            in <{ setret ;  cl }>
        | _ => Skip end 
        in
        let body := <{bdecls ; inits ; code ; ret_and_cleanup }> in 
        let gen_f := signature [] body in 
        mkTR _ (globals,gen_f) new_env []

    | None => ret (mkTR _ ([],PFun Void "" [] [] Skip : gmp_routine) env [])
    end
.


Definition translate_program (bindings : Γᵥ) (t_inf : type_inf) (p: fsl_pgrm)  : rac_pgrm := 

    (* generate from left to right the globals and function definitions *)
    let res := List.fold_left (
        fun (done : @state ((list _ * list gmp_routine) * ψ)%type) (doing:fsl_routine)  => 
            (* get the declarations, functions and last ψ computed so far *)
            done_res <- done ;;
            let '((decls,funs) , env) := done_res in 

            match doing with 
            | PFun rtype name args decls body =>

                (* translate the current function, passing to it the last ψ *)
                body_tr <- translate_statement bindings t_inf env body ;;; 
                let tr_res := mkTR gmp_routine (PFun rtype name args decls body_tr.(chunk))  body_tr.(tenv) body_tr.(glob) in

                (* add the collected globals to the declarations *)
                let decls := app decls tr_res.(glob) in

                (* appened to the end of the other functions the new translated one *)
                let funs := app funs [tr_res.(chunk)] in  
                ((decls,funs), tr_res.(tenv))

            | _ => 
                (* we only translate c functions *)
                (* article doesn't mention direct translation of logic functions / predicates but rather 
                    (possibly) generates them when they are called  
                    ->  are we supposed to fill up the logic functions env ? 
                 *)
                ret done_res
            end
            
    ) (snd p) (ret ((fst p,[]),(⊥:ψ))) in

    
    fst (exec res) 
.